var hd =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/hotdrink.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/computation-graph.js":
/*!**********************************!*\
  !*** ./lib/computation-graph.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MethodActivation = exports.VariableActivation = void 0;\n\nvar util = _interopRequireWildcard(__webpack_require__(/*! ../src/utilities */ \"./src/utilities.js\"));\n\nvar hd = _interopRequireWildcard(__webpack_require__(/*! ../src/constraint-system */ \"./src/constraint-system.js\"));\n\nvar _hdconsole = __webpack_require__(/*! ../src/hdconsole */ \"./src/hdconsole.js\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n} // [[file:~/git/hd4/org/computation-graph.org::*Tangle][Tangle:2]]\n\n\nclass Deferred {\n  constructor() {\n    this._promise = new Promise((r, j) => {\n      this.resolve = v => {\n        r(v);\n      };\n\n      this.reject = e => {\n        j(e);\n      };\n    });\n  }\n\n  get promise() {\n    return this._promise;\n  }\n\n}\n\nclass TrackingPromise {\n  constructor(p, tracker) {\n    this._promise = p;\n    this._fulfillTracker = tracker;\n  }\n\n  then(onFulfilled, onRejected) {\n    if (onFulfilled != null) this._fulfillTracker();\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    return this._promise.catch(onRejected);\n  }\n\n  finally(onFinally) {\n    return this._promise.finally(onFinally);\n  }\n\n}\n\nconst abandoned = {};\n\nclass VariableActivation {\n  constructor(v) {\n    this._pending = false;\n    this._variable = v;\n    this._deferred = new Deferred();\n    this._outMethods = new Set();\n    this._inMethod = null;\n    util.mkRefCounted(this, t => {\n      t.reject(VariableActivation.abandoned);\n      t._inMethod = null;\n      return;\n    });\n  }\n\n  get name() {\n    return this._variable.name;\n  }\n\n  get inMethod() {\n    return this._inMethod;\n  }\n\n  get outMethods() {\n    return this._outMethods;\n  }\n\n  outMethodsSize() {\n    return this._outMethods.size;\n  }\n\n  addOutMethod(m) {\n    this._outMethods.add(m);\n  }\n\n  setInMethod(m) {\n    this._inMethod = m;\n  }\n\n  resolve(v) {\n    this._pending = false;\n    return this._deferred.resolve(v);\n  }\n\n  reject(e) {\n    this._pending = false;\n    return this._deferred.reject(e);\n  }\n\n  get promise() {\n    return this._deferred.promise;\n  }\n\n}\n\nexports.VariableActivation = VariableActivation;\nVariableActivation.abandoned = {};\n\nclass MethodActivation {\n  constructor(f, promiseMask) {\n    this._f = f;\n    this._mask = promiseMask;\n  }\n\n  get ins() {\n    return this._ins;\n  }\n\n  get outs() {\n    return this._outs;\n  }\n\n  insSize() {\n    return this._ins.length;\n  }\n\n  outsSize() {\n    return this._outs.length;\n  }\n\n  async execute(ins, outs) {\n    this._ins = ins;\n    this._outs = outs;\n    outs.forEach(o => o.setInMethod(this)); // retain all inputs\n\n    ins.forEach(i => util.retain(i)); // once _all_ output variable activations have been settled\n    // (either by this method or by becoming abandoned), this method\n    // activation has no use anymore; in particular it does not need\n    // its input activations anymore, and it will release them.  We\n    // use Promise.all to detect when all outputs have been settled\n    // or rejected, but since Promise.all rejects immediately if any\n    // of the promises it waits rejects, we do not wait for the output\n    // promises directly, but rather for another set of promises\n    // (oproms) that wrap the output promises and resolve regardless\n    // whether the corresponding outputs reject or resolve.\n\n    let oproms = outs.map(o => o.promise.then(v => null, e => null));\n    Promise.all(oproms).then(() => {\n      ins.forEach(i => {\n        util.release(i);\n      });\n    }); // FIXME: this can be replaced with Promise.allSettled(), once\n    // it becomes supported\n\n    let nonpromiseIns = ins.filter((e, i) => (this._mask[i] & hd.maskPromise) === 0); // these are regular in-parameters that are awaited before passing into method's f\n\n    let modifiedIns = ins.filter((e, i) => (this._mask[i] & hd.maskUpdate) !== 0); // these are the inputs that are also outputs, and where there is aliasing between\n    // the input and the output. Methods that perform this kind of modification can only \n    // be executed when the inputs have reference count 1 (then all the other methods that\n    // use those inputs have already finished (there can be at most one method that performs\n    // such a modifying write)\n\n    let mCount = modifiedIns.length;\n\n    if (mCount > 0) {\n      let def = new Deferred();\n      let arr = [];\n\n      for (let i = 0; i < modifiedIns.length; ++i) {\n        arr.push(modifiedIns[i].name);\n        util.setUniqueHandler(modifiedIns[i], v => {\n          if (--mCount === 0) def.resolve(null);\n        });\n      }\n\n      await def.promise; // now all possibly modifying variables have only one reference\n    }\n\n    let inValues;\n\n    try {\n      // await for all non-promise inputs\n      inValues = await Promise.all(nonpromiseIns.map(v => v.promise));\n    } catch (e) {\n      // if any non-promise input rejects, the wrapped f cannot be called, so\n      // all outputs can be rejected\n      outs.forEach(o => o.reject(\"a method's input was rejected\"));\n      return;\n    } // construct the wrapped f's input argument from promise inputs\n    // and the resolved values of non-promise inputs\n\n\n    let inArgs = [],\n        vind = 0;\n\n    for (let i = 0; i < ins.length; ++i) {\n      if ((this._mask[i] & hd.maskPromise) !== 0) {\n        inArgs[i] = new TrackingPromise(ins[i].promise, () => ins[i].addOutMethod(this));\n      } else {\n        ins[i].addOutMethod(this);\n        inArgs[i] = inValues[vind++];\n      }\n    }\n\n    let r;\n\n    try {\n      r = await this._f(...inArgs); // in case of one return, result can be\n      // a promise, we await for it here to\n      // avoid unhandled rejection. (This also\n      // allows a method that returns a\n      // promise that resolves to an array)\n    } catch (e) {\n      // this error is from f itself; therefore we reject all outputs\n      // with the reason e\n      outs.forEach(o => o.reject(e));\n      return;\n    } // if method has more than one output, f should return an array\n\n\n    if (outs.length > 1) {\n      console.assert(Array.isArray(r) && outs.length == r.length, `Method result shoud be an array of ${outs.length} elements`);\n\n      for (let i = 0; i < r.length; ++i) outs[i].resolve(r[i]); // r[i] can be a promise or a value\n\n    } else {\n      // only one output; result of f is not expected to be wrapped in a singleton array\n      outs[0].resolve(r);\n    }\n  }\n\n}\n\nexports.MethodActivation = MethodActivation;\n\nclass EvaluationGraph {\n  adjacentOutVertices(v) {\n    if (v instanceof VariableActivation) return v.outMethods;else return v.outs;\n  }\n\n  outDegree(v) {\n    if (v instanceof VariableActivation) return v.outMethodsSize();else return v.outsSize();\n  }\n\n  adjacentInVertices(v) {\n    if (v instanceof VariableActivation) return v.inMethod != null ? [v.inMethod] : [];else return v.ins;\n  }\n\n  inDegree(v) {\n    if (v instanceof VariableActivation) return v.inMethod != null ? 1 : 0;else return v.insSize();\n  }\n\n} // Tangle:2 ends here\n\n//# sourceURL=webpack://hd/./lib/computation-graph.js?");

/***/ }),

/***/ "./lib/constraint-builder.js":
/*!***********************************!*\
  !*** ./lib/constraint-builder.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.component = component;\nexports.isLeft = isLeft;\nexports.isRight = isRight;\nexports.withPos = withPos;\nObject.defineProperty(exports, \"ParseState\", {\n  enumerable: true,\n  get: function () {\n    return _parsing.ParseState;\n  }\n});\nObject.defineProperty(exports, \"mkParseState\", {\n  enumerable: true,\n  get: function () {\n    return _parsing.mkParseState;\n  }\n});\nObject.defineProperty(exports, \"hdl\", {\n  enumerable: true,\n  get: function () {\n    return _parsing.hdl;\n  }\n});\nexports.TypeError = void 0;\n\nvar _parsing = __webpack_require__(/*! ../src/parsing */ \"./src/parsing.js\");\n\nvar _lexingTools = __webpack_require__(/*! ../src/lexing-tools */ \"./src/lexing-tools.js\");\n\nvar util = _interopRequireWildcard(__webpack_require__(/*! ../src/utilities */ \"./src/utilities.js\"));\n\nvar cs = _interopRequireWildcard(__webpack_require__(/*! ../src/constraint-system */ \"./src/constraint-system.js\"));\n\nvar _hdconsole = __webpack_require__(/*! ../src/hdconsole */ \"./src/hdconsole.js\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst LEFT = 0;\nconst RIGHT = 1;\n\nfunction left(v) {\n  return {\n    tag: LEFT,\n    value: v\n  };\n}\n\nfunction right(v) {\n  return {\n    tag: RIGHT,\n    value: v\n  };\n} // %checks do not work\n\n\nfunction isLeft(e) {\n  return e.tag === LEFT;\n}\n\nfunction isRight(e) {\n  return e.tag === RIGHT;\n}\n\nfunction asLeft(e) {\n  if (e.tag !== LEFT) throw \"Either cast error: no value on left\";\n  return e.value;\n}\n\nfunction asRight(e) {\n  if (e.tag !== RIGHT) throw e.value;\n  return e.value;\n}\n\nfunction withPos(p) {\n  return (0, _parsing.lift2)((cp, v) => ({\n    pos: cp,\n    value: v\n  }))(_parsing.currentPos, p);\n}\n\nclass ComponentScope {\n  constructor(cmp) {\n    this._component = cmp;\n  }\n\n  get(key) {\n    let m = this._component;\n\n    while (m != null) {\n      let v = m.variableDeclarations.get(key);\n      if (v !== undefined) return v;else m = m.parent;\n    }\n  }\n\n  has(key) {\n    return this.get(key) !== undefined;\n  }\n\n}\n\nclass SetScope {\n  constructor(s) {\n    this._set = s;\n  }\n\n  get(k) {\n    return this.has(k) ? k : undefined;\n  }\n\n  has(k) {\n    return this._set.has(k);\n  }\n\n}\n\nclass TypeError extends Error {\n  constructor(m, p) {\n    super();\n    this._msg = m;\n    this._pos = p;\n  }\n\n  get message() {\n    return this._pos.toString() + \"\\n\" + this._msg;\n  }\n\n  set message(s) {\n    throw Error(\"Cannot set the name of ParseError\");\n  }\n\n}\n\nexports.TypeError = TypeError;\n\nfunction checkQualifiers(qs) {\n  if (qs.length > 1) {\n    let seen = new Set();\n\n    for (let q of qs) {\n      if (seen.has(q.value)) return left(new TypeError(`The same qualifier ${q.value} appears twice`, q.pos));\n      seen.add(q.value);\n    }\n  }\n\n  return right(null);\n}\n\nfunction checkParameterList(pars, scope) {\n  let seenName = new Set();\n\n  for (let par of pars) {\n    // check qualifiers for duplicates\n    let r = checkQualifiers(par.value.qualifiers);\n    if (isLeft(r)) return left(asLeft(r)); // check if variable name duplicate\n\n    let pn = par.value.parameterName;\n\n    if (!scope.has(pn.value)) {\n      return left(new TypeError(`Undefined variable name ${pn.value}`, pn.pos));\n    }\n\n    if (seenName.has(pn.value)) return left(new TypeError(`Parameter ${pn.value} appears twice in the same parameter list`, pn.pos));\n    seenName.add(pn.value);\n  }\n\n  return right(seenName);\n}\n\nfunction checkFirstMethod(m, scope) {\n  let ins = checkParameterList(m.ins, scope);\n  if (isLeft(ins)) return ins;\n  let outs = checkParameterList(m.outs, scope);\n  if (isLeft(outs)) return outs;\n  return right(util.setUnion(asRight(ins), asRight(outs)));\n}\n\nfunction checkOtherMethod(m, expectedVariableNames) {\n  let scope = new SetScope(expectedVariableNames);\n  let ins = checkParameterList(m.ins, scope);\n  if (isLeft(ins)) return left(asLeft(ins));\n  let outs = checkParameterList(m.outs, scope);\n  if (isLeft(outs)) return left(asLeft(outs));\n  let foundNames = util.setUnion(asRight(ins), asRight(outs));\n\n  if (!util.setEquals(foundNames, expectedVariableNames)) {\n    let missingVariables = Array.from(util.setDifference(expectedVariableNames, foundNames)).join();\n    return left(new TypeError(`All methods in the same constraint must use the same variables; this method does not refer to variable ` + missingVariables, m.pos));\n  }\n\n  ; // FIXME: should test for method restriction    \n\n  return right(null);\n}\n\nfunction checkConstraint(c, scope) {\n  if (c.methods.length === 0) {\n    c.variableNames = new Set();\n    return right(c);\n  }\n\n  let vs = checkFirstMethod(c.methods[0], scope);\n  if (isLeft(vs)) return left(asLeft(vs));\n  c.variableNames = asRight(vs);\n\n  for (let i = 1; i < c.methods.length; ++i) {\n    let r = checkOtherMethod(c.methods[i], asRight(vs));\n    if (isLeft(r)) return left(asLeft(r));\n  }\n\n  return right(c);\n}\n\nfunction checkComponent(cmp) {\n  for (let c of cmp.constraints) {\n    let r = checkConstraint(c, new ComponentScope(cmp));\n    if (isLeft(r)) return left(asLeft(r));\n  }\n\n  for (let c of cmp.components) {\n    let r = checkComponent(c);\n\n    if (isLeft(r)) {\n      return left(asLeft(r));\n    }\n  }\n\n  return right(cmp);\n}\n\nfunction jsCode(endMarkers, includeMarker = true) {\n  return ps => {\n    let s = \"\";\n\n    while (true) {\n      let nc = ps.peek();\n\n      if (nc == null) {\n        if (endMarkers.includes(\"\")) return (0, _parsing.ok)(s, s.length > 0);else return (0, _parsing.failF)(() => [\"<js code>\"].concat(endMarkers), s.length > 0);\n      }\n\n      if (endMarkers.includes(nc)) {\n        if (includeMarker) {\n          (0, _parsing.item)(ps);\n          s += nc;\n        }\n\n        return (0, _parsing.ok)(s);\n      }\n\n      if ([\"}\", \"]\", \")\"].includes(nc)) return (0, _parsing.fail)([\"not \" + nc], true); // mismatched brace\n\n      let r = (0, _parsing.oneOf)(stringLiteral, templateLiteral, (0, _parsing.pBind)((0, _parsing.sat)(isOpenBrace), b => (0, _parsing.pBind)(jsCode([closingBraceOf(b)], true), c => (0, _parsing.ret)(b + c))), _parsing.item)(ps);\n      if (!r.success) return r;\n      s += r.value;\n    }\n\n    throw null; // dead code (needed to supress flowtype's complaint about mismatch in return type\n  };\n}\n\nfunction isOpenBrace(c) {\n  return c == \"(\" || c == \"{\" || c == \"[\";\n}\n\nfunction closingBraceOf(c) {\n  switch (c) {\n    case \"(\":\n      return \")\";\n\n    case \"{\":\n      return \"}\";\n\n    case \"[\":\n      return \"]\";\n  }\n\n  throw Error(\"HotDrink internal error: no closing brace defined for \" + c);\n}\n\nfunction stringLiteral(ps) {\n  let r = (0, _parsing.oneOf)((0, _parsing.pChar)(\"'\"), (0, _parsing.pChar)('\"'))(ps);\n  if (!r.success) return r;\n  const quote = r.value,\n        equote = \"\\\\\" + quote;\n  let str = r.value;\n  r = (0, _parsing.lift)((s, q) => str + s.join('') + q, (0, _parsing.many)((0, _parsing.oneOf)((0, _parsing.exactString)(\"\\\\\\\\\"), (0, _parsing.exactString)(equote), (0, _parsing.sat)(c => c != quote))), (0, _parsing.pChar)(quote))(ps);\n  r.consumed = true; // we know by now the parser has consumed\n  // in case there is an error, it must be reading <eof> expecting quote\n\n  return r;\n}\n\nfunction templateLiteral(ps) {\n  const quote = \"`\",\n        equote = \"\\\\\" + quote;\n  let r = (0, _parsing.pChar)(quote)(ps);\n  if (!r.success) return r;\n  let str = r.value;\n\n  while (true) {\n    let r = (0, _parsing.must)((0, _parsing.oneOf)((0, _parsing.pChar)(quote), (0, _parsing.exactString)(\"${\"), (0, _parsing.exactString)(\"\\\\\\\\\"), (0, _parsing.exactString)(equote), _parsing.item))(ps); // throws if out of input                       \n\n    if (r.value == quote) {\n      str += quote;\n      break;\n    }\n\n    if (r.value == \"${\") {\n      str += \"${\";\n      str += (0, _parsing.must)(jsCode([\"}\"]))(ps).value;\n      continue;\n    }\n\n    str += r.value;\n  }\n\n  return (0, _parsing.ok)(str);\n}\n\nconst block = (0, _parsing.context)(\"<function body block>\", (0, _parsing.token)((0, _parsing.lift)((open, code_and_close) => open + code_and_close, (0, _parsing.pChar)(\"{\"), jsCode([\"}\"]))));\nconst functionBody = (0, _parsing.context)(\"<function body>\", (0, _parsing.oneOf)(block, (0, _parsing.pBind)((0, _parsing.token)(jsCode([\";\"])), body => (0, _parsing.ret)(\"return \" + body))));\n\nfunction pMethod(ps) {\n  function _met(pos, name, ins, outs, body) {\n    // for each input argument, construct a mask that tells which qualifiers were used\n    let promiseMask = ins.map(p => {\n      return util.foldl((q1, q2) => orMasks(qualifier2mask(q1), q2), cs.maskNone, p.value.qualifiers.map(q => q.value));\n    });\n    const inparNames = ins.map(p => p.value.parameterName.value);\n    let code;\n\n    if (typeof body.value === 'string') {\n      code = {\n        pos: body.pos,\n        value: new Function(inparNames.join(), body.value)\n      };\n    } else code = body; // body was a spliced expression, so body.value must be a Function already\n\n\n    return {\n      pos,\n      name,\n      ins,\n      outs,\n      code,\n      promiseMask\n    };\n  }\n\n  const bodyParser = withPos((0, _parsing.oneOf)((0, _parsing.lift)((v, _) => v, _parsing.pSplice, (0, _parsing.word)(\";\")), (0, _parsing.pBind_)((0, _parsing.word)(\"=>\"), functionBody), block));\n  return (0, _parsing.context)(\"<method>\", (0, _parsing.lift)(_met, _parsing.currentPos, (0, _parsing.opt)(withPos(_parsing.identifier), null), (0, _parsing.ignore)((0, _parsing.word)(\"(\")), qualifiedParameterList(\"*!\"), (0, _parsing.ignore)((0, _parsing.word)(\"->\")), qualifiedParameterList(\"\"), (0, _parsing.ignore)((0, _parsing.word)(\")\")), bodyParser))(ps);\n}\n\nfunction qualifier2mask(q) {\n  switch (q) {\n    case \"*\":\n      return cs.maskPromise;\n\n    case \"!\":\n      return cs.maskUpdate;\n\n    default:\n      return cs.maskNone;\n  }\n}\n\nfunction orMasks(m1, m2) {\n  return m1 | m2;\n}\n\nfunction qualifierList(qualifiers) {\n  return (0, _parsing.many)((0, _parsing.token)(withPos((0, _parsing.pChars)(qualifiers))));\n}\n\nfunction qualifiedParameterList(qualifiers = \"*!\") {\n  // \n  return (0, _parsing.sepList)(withPos((0, _parsing.lift)((qs, pname) => ({\n    qualifiers: qs,\n    parameterName: pname\n  }), qualifierList(qualifiers), withPos(_parsing.identifier))), (0, _parsing.word)(\",\"));\n}\n\nfunction pVariables(ps) {\n  return (0, _parsing.inBetween)((0, _parsing.sepList)(identifierWithOptionalInitializer, (0, _parsing.word)(\",\")), (0, _parsing.word)(\"var\"), (0, _parsing.word)(\";\"))(ps);\n}\n\nfunction identifierWithOptionalInitializer(ps) {\n  return (0, _parsing.pBind)(_parsing.currentPos, pos => (0, _parsing.oneOf)((0, _parsing.lift)(name => ({\n    pos,\n    name,\n    isReference: true\n  }), (0, _parsing.ignore)((0, _parsing.word)(\"&\")), _parsing.identifier), (0, _parsing.lift)((name, initializer) => ({\n    pos,\n    name,\n    isReference: false,\n    initializer\n  }), _parsing.identifier, (0, _parsing.opt)(withPos(initializerExpression), undefined))))(ps);\n}\n\nfunction initializerExpression(ps) {\n  return (0, _parsing.pBind_)((0, _parsing.word)(\"=\"), (0, _parsing.context)(\"<intitializer-expression>\", (0, _parsing.pBind)(jsCode([\",\", \";\"], false), e => (0, _parsing.ret)(new Function(\"return \" + e)()))))(ps);\n}\n\nfunction pConstraint(ps) {\n  return (0, _parsing.context)(\"<constraint>\", (0, _parsing.lift)((pos, name, methods) => ({\n    pos,\n    name,\n    variableNames: null,\n    methods\n  }), _parsing.currentPos, (0, _parsing.ignore)((0, _parsing.word)(\"constraint\")), (0, _parsing.opt)(withPos(_parsing.identifier), null), (0, _parsing.ignore)((0, _parsing.word)(\"{\")), (0, _parsing.many)(pMethod), (0, _parsing.ignore)((0, _parsing.word)(\"}\"))))(ps);\n}\n\nconst mkComponentAST = (pos, name, declarations) => {\n  let variableDeclarations = new Map();\n  let constraints = [];\n  let components = [];\n  let node = {\n    parent: null,\n    pos,\n    name,\n    variableDeclarations,\n    constraints,\n    components\n  };\n\n  for (let decl of declarations) {\n    switch (decl.tag) {\n      case 'variable':\n        for (let vdecl of decl.value) {\n          variableDeclarations.set(vdecl.name, vdecl);\n        }\n\n        break;\n\n      case 'constraint':\n        constraints.push(decl.value);\n        break;\n\n      case 'component':\n        decl.value.parent = node;\n        components.push(decl.value);\n        break;\n    }\n  }\n\n  return node;\n};\n\nconst componentBody = (0, _parsing.many)((0, _parsing.oneOf)((0, _parsing.pBind)(pVariables, v => (0, _parsing.ret)({\n  tag: 'variable',\n  value: v\n})), (0, _parsing.pBind)(pConstraint, v => (0, _parsing.ret)({\n  tag: 'constraint',\n  value: v\n})), (0, _parsing.pBind)(pComponent, v => (0, _parsing.ret)({\n  tag: 'component',\n  value: v\n}))));\n\nfunction topComponent(name) {\n  return ps => {\n    return (0, _parsing.lift)(mkComponentAST, _parsing.currentPos, withPos((0, _parsing.ret)(name)), componentBody)(ps);\n  };\n}\n\nfunction pComponent(ps) {\n  return (0, _parsing.context)(\"<component>\", (0, _parsing.lift)(mkComponentAST, _parsing.currentPos, (0, _parsing.ignore)((0, _parsing.word)(\"component\")), withPos(_parsing.identifier), (0, _parsing.ignore)((0, _parsing.word)(\"{\")), componentBody, (0, _parsing.ignore)((0, _parsing.word)(\"}\"))))(ps);\n}\n\nfunction component(strs, ...splices) {\n  let ps = (0, _parsing.hdl)(strs, ...splices);\n  let r = (0, _parsing.must)((0, _parsing.pBind_)(_parsing.manyws, (0, _parsing.oneOf)(pComponent, topComponent(cs.freshComponentName()))))(ps);\n  (0, _parsing.must)(_parsing.eof)(ps);\n  return buildComponent(asRight(checkComponent(r.value)));\n}\n\nfunction buildMethod(mnode, vmap) {\n  return new cs.Method(vmap.size, mnode.ins.map(v => vmap.get(v.value.parameterName.value)), mnode.outs.map(v => vmap.get(v.value.parameterName.value)), mnode.promiseMask, mnode.code.value, mnode.name == undefined ? \"\" : mnode.name.value);\n}\n\nfunction buildAndAddConstraint(owner, cnode) {\n  if (cnode.variableNames == null) throw Error(\"Constraint node must be type checked before it is used for building a constraint\");\n  let name2index = new Map();\n  let index = 0;\n\n  for (let v of cnode.variableNames) name2index.set(v, index++);\n\n  let ms = cnode.methods.map(m => buildMethod(m, name2index));\n  let vrefs = Array.from(name2index.keys(), name => owner.getVariableReference(name));\n  let cspec = new cs.ConstraintSpec(ms);\n  let name = cnode.name != null ? cnode.name.value : null;\n  return owner.emplaceConstraint(name, cspec, vrefs, false);\n}\n\nfunction buildComponent(compNode, owner = null) {\n  let comp = new cs.Component(compNode.name.value);\n  if (owner != null) owner.addComponent(comp);\n\n  for (let vdecl of compNode.variableDeclarations.values()) {\n    if (vdecl.isReference) comp.emplaceVariableReference(vdecl.name);else {\n      let init = vdecl.initializer != null ? vdecl.initializer.value : undefined;\n      comp.emplaceVariable(vdecl.name, init);\n    }\n  }\n\n  compNode.constraints.forEach(c => buildAndAddConstraint(comp, c));\n  compNode.components.forEach(c => buildComponent(c, comp));\n  return comp;\n}\n\n//# sourceURL=webpack://hd/./lib/constraint-builder.js?");

/***/ }),

/***/ "./lib/constraint-system.js":
/*!**********************************!*\
  !*** ./lib/constraint-system.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mkVariable = mkVariable;\nexports.isOwnerOf = isOwnerOf;\nexports.enforceStayMethod = enforceStayMethod;\nexports.isStay = isStay;\nexports.SimplePlanner = exports.UpstreamSolutionGraph = exports.DownstreamSolutionGraph = exports.ConstraintSystem = exports.Constraint = exports.freshComponentName = exports.Component = exports.Variable = exports.VariableReference = exports.ConstraintSpec = exports.Method = exports.maskPromiseUpdate = exports.maskUpdate = exports.maskPromise = exports.maskNone = void 0;\n\nvar _graphAlgorithms = __webpack_require__(/*! ./graph-algorithms */ \"./lib/graph-algorithms.js\");\n\nvar _computationGraph = __webpack_require__(/*! ./computation-graph */ \"./lib/computation-graph.js\");\n\nvar _hdconsole = __webpack_require__(/*! ./hdconsole */ \"./lib/hdconsole.js\");\n\nvar Obs = _interopRequireWildcard(__webpack_require__(/*! ./observable */ \"./lib/observable.js\"));\n\nvar util = _interopRequireWildcard(__webpack_require__(/*! ./utilities */ \"./lib/utilities.js\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst maskNone = 0;\nexports.maskNone = maskNone;\nconst maskPromise = 1;\nexports.maskPromise = maskPromise;\nconst maskUpdate = 2;\nexports.maskUpdate = maskUpdate;\nconst maskPromiseUpdate = maskPromise | maskUpdate;\nexports.maskPromiseUpdate = maskPromiseUpdate;\n\nclass Method {\n  constructor(nvars, ins, outs, promiseMask, code, name) {\n    this._ins = new Set(ins);\n    this._outs = new Set(outs); // compute _nonOuts\n\n    let indices = Array.from(Array(nvars).keys()); // [0, 1, ..., nvars-1]\n\n    this._outs.forEach(i => indices[i] = null); // mark with null the indices that are outputs\n\n\n    this._nonOuts = new Set();\n\n    for (let e of indices) {\n      if (e != null) this._nonOuts.add(e);\n    }\n\n    this._promiseMask = Array.from(promiseMask);\n\n    _hdconsole.hdconsole.assert(this._ins.size == this._promiseMask.length, \"Number of input arguments and length of promise mask must be the same\");\n\n    this.code = code;\n    if (name != null) this._name = name;\n  }\n\n  get name() {\n    return this._name == null ? \"\" : this._name;\n  }\n\n  get nvars() {\n    return this._outs.size + this._nonOuts.size;\n  }\n\n  validIndex(i) {\n    return i >= 0 && i < this.nvars;\n  }\n\n  ins() {\n    return this._ins;\n  }\n\n  outs() {\n    return this._outs;\n  }\n\n  nonOuts() {\n    return this._nonOuts;\n  }\n\n  vIns(vs) {\n    return util.map(i => vs[i], this._ins);\n  }\n\n  vOuts(vs) {\n    return util.map(i => vs[i], this._outs);\n  }\n\n  vNonOuts(vs) {\n    return util.map(i => vs[i], this._nonOuts);\n  }\n\n  nIns() {\n    return this._ins.size;\n  }\n\n  nOuts() {\n    return this._outs.size;\n  }\n\n  nNonOuts() {\n    return this._nonOuts.size;\n  }\n\n  isIn(i) {\n    return this._ins.has(i);\n  }\n\n  isOut(i) {\n    return this._outs.has(i);\n  }\n\n  isNonOut(i) {\n    return this._nonOuts.has(i);\n  }\n\n  prettyPrint(vrefs) {\n    let s = this.name + \"(\";\n\n    for (const i of this._nonOuts) s += vrefs[i].name + \" \";\n\n    s += \"->\";\n\n    for (const i of this._outs) s += \" \" + vrefs[i].name;\n\n    s += \");\";\n    return s;\n  }\n\n}\n\nexports.Method = Method;\n\nclass ConstraintSpec {\n  constructor(methods) {\n    this._methods = new Set(methods);\n\n    _hdconsole.hdconsole.assert(this._methods.size > 0, \"Constraint specification must have at least one method.\");\n\n    const nvars = util.first(this._methods).nvars;\n    this._nvars = nvars;\n    this._v2ins = [];\n\n    for (let i = 0; i < nvars; ++i) this._v2ins.push([]);\n\n    for (let m of this._methods) {\n      _hdconsole.hdconsole.assert(m.nvars === nvars, `All methods in constraint specification must have the same number of variables`);\n\n      for (let i of m.outs()) {\n        this._v2ins[i].push(m);\n      }\n    }\n  }\n\n  get nvars() {\n    return this._nvars;\n  }\n\n  ins(vIndex) {\n    return this._v2ins[vIndex];\n  }\n\n  insSize(vIndex) {\n    return this._v2ins[vIndex].length;\n  }\n\n  methods() {\n    return this._methods;\n  }\n\n  hasMethod(m) {\n    return this._methods.has(m);\n  }\n\n  prettyPrint(prefix, vrefs) {\n    let s = \"\";\n\n    for (let m of this._methods) {\n      s += prefix + m.prettyPrint(vrefs) + \"\\n\";\n    }\n\n    return s;\n  }\n\n}\n\nexports.ConstraintSpec = ConstraintSpec;\n\nclass VariableReference extends util.ObservableReference {\n  constructor(owner) {\n    super();\n    this._owner = owner;\n  }\n\n  get system() {\n    return this._owner.system;\n  }\n\n  get name() {\n    return this._owner.variableReferenceName(this);\n  }\n\n  isOwningReference() {\n    return this.value == null ? false : this.value._owner === this;\n  }\n\n  prettyPrint() {\n    let s = this.name;\n    if (this.value != null) s += \":\" + this.value._index;\n    return s;\n  }\n\n}\n\nexports.VariableReference = VariableReference;\n\nfunction mkVariable(owner, v) {\n  let r = new VariableReference(owner);\n  r.value = new Variable(r, v);\n  return r;\n}\n\nlet freshIndex = (() => {\n  let ind = 0;\n  return () => ++ind;\n})();\n\nclass Variable {\n  // for debugging purposes\n  // holds observers\n  get value() {\n    return this._inError ? undefined : this._value;\n  }\n\n  get error() {\n    return this._inError ? this._error : undefined;\n  }\n\n  get stale() {\n    return !this._pending && this._inError;\n  }\n\n  get pending() {\n    return this._pending;\n  }\n\n  constructor(owner, v = undefined) {\n    this._index = freshIndex();\n    this._owner = owner;\n    this._value = undefined;\n    this._error = undefined;\n    this._inError = false;\n    this._pending = true;\n    this._subject = new Obs.Subject(o => {\n      let evt = {\n        value: this._value,\n        pending: this._pending,\n        inError: this._inError\n      };\n      if (this._inError) evt.error = this._error;\n      o.next(evt);\n    });\n    this.pushNewActivation();\n    if (v !== undefined) this._activation.resolve(v);\n  }\n\n  subscribe(o) {\n    return this._subject.subscribe(o);\n  }\n\n  subscribeValue(o) {\n    return this._subject.filter(e => e.hasOwnProperty('value')).map(e => e.value).subscribe(o);\n  }\n\n  subscribePending(o) {\n    return this._subject.filter(e => e.hasOwnProperty('pending')).map(e => e.pending).subscribe(o);\n  }\n\n  subscribeError(o) {\n    return this._subject.filter(e => e.hasOwnProperty('inError') || e.hasOwnProperty('error')).map(e => {\n      let r = {};\n      if (e.hasOwnProperty('error')) r.error = e.error;\n      if (e.hasOwnProperty('inError')) r.inError = e.inError;\n      return r;\n    }).subscribe(o);\n  }\n\n  pushNewActivation() {\n    let r = new _computationGraph.VariableActivation(this);\n    this._activation = r;\n\n    if (this._pending === false) {\n      this._pending = true;\n\n      this._subject.sendNext({\n        pending: true\n      });\n    }\n\n    r.promise.then(val => {\n      if (r === this._activation) {\n        // is the activation still the newest\n        this._value = val;\n        let evt = {\n          value: val\n        };\n\n        if (this._inError) {\n          this._inError = false;\n          evt.inError = false;\n        }\n\n        this._pending = false;\n        evt.pending = false;\n\n        this._subject.sendNext(evt);\n      }\n    }, e => {\n      if (r === this._activation) {\n        this._error = e;\n        let evt = {\n          error: e\n        };\n\n        if (!this._inError) {\n          this._inError = true;\n          evt.inError = true;\n        }\n\n        this._pending = false;\n        evt.pending = false;\n\n        this._subject.sendNext(evt);\n      }\n    });\n    return r;\n  }\n\n  get currentPromise() {\n    return this._activation.promise;\n  }\n\n  get owner() {\n    return this._owner;\n  }\n\n  get system() {\n    return this._owner.system;\n  }\n\n  get name() {\n    if (this._owner == null) return \"<unnamed>\";else return this._owner.name;\n  }\n\n  set(v) {\n    this.assign(v);\n    let s = this.system;\n    if (s != null) s.updateDirty();\n    return this;\n  }\n\n  fail(e) {\n    this._assign().reject(e);\n\n    let s = this.system;\n    if (s != null) s.updateDirty();\n    return this;\n  }\n\n  assign(v) {\n    this._assign().resolve(v);\n  }\n\n  _assign() {\n    let prevActivation = this._activation;\n    this.pushNewActivation();\n    let s = this.system;\n\n    if (s != null) {\n      s.promoteVariable(this);\n      let sc = s.getSourceConstraint(this);\n      if (sc != null) s.setDirty(sc);\n      s.setDirty(s.getStay(this));\n    }\n\n    util.release(prevActivation);\n    return this._activation;\n  }\n\n  touch() {\n    let s = this.system;\n    if (s != null) s.promoteVariable(this);\n    return this;\n  }\n\n  _touchPlanSolve() {\n    this.touch();\n    let s = this.system;\n    let prevActivation = this._activation;\n    this.pushNewActivation();\n\n    if (s == null) {\n      util.release(prevActivation);\n      return this._activation;\n    }\n\n    let pushedActivation = this._activation;\n    let sc = s.getSourceConstraint(this);\n    s.setDirty(sc != null ? sc : s.getStay(this));\n    s.updateDirty(); // solving pushes new activations to variables, also possibly to this._activation.\n    // This happens if 'this' cannot stay in the current plan.\n\n    util.release(prevActivation); // return the activation that should be resolved or rejected\n\n    return pushedActivation;\n  }\n\n}\n\nexports.Variable = Variable;\n\nclass Component {\n  // used for generating fresh constraint names\n  constructor(name) {\n    this._owner = null;\n    this._system = null;\n    this._name = name;\n    this._vars = new Set();\n    this._varRefs = new Map();\n    this._varRefNames = new Map();\n    this._constraints = new Map();\n    this._constraintNames = new Map();\n    this._nextFreshCIndex = 0;\n    this._components = new Map();\n  }\n\n  clone(name = freshComponentName()) {\n    let that = new Component(name);\n    let o2n = new Map(); // old2new \n    // clone variable references\n\n    for (let [n, v] of this._varRefs) {\n      if (v.isOwningReference()) {\n        o2n.set(v, that.emplaceVariable(n));\n      } else o2n.set(v, that.emplaceVariableReference(n));\n    } // clone constraints\n\n\n    for (let [n, c] of this._constraints) {\n      let nrefs = c._varRefs.map(vr => o2n.get(vr));\n\n      if (!isStay(c)) that.emplaceConstraint(n, c._cspec, nrefs, c._optional);\n    } // clone nested components\n\n\n    for (let [n, cmp] of this._components) that.addComponent(cmp.clone(n));\n\n    return that;\n  }\n\n  get system() {\n    return this._system;\n  }\n\n  connectSystem(system) {\n    if (this._owner != null) {\n      _hdconsole.hdconsole.error(`Tried to connect the nested component ${this._name}`);\n\n      return false;\n    }\n\n    if (this._system === system) {\n      _hdconsole.hdconsole.warn(`Same system connected twice to component ${this._name}`);\n\n      return false;\n    }\n\n    if (this._system != null) {\n      _hdconsole.hdconsole.error(`Trying to connect an already connected component ${this._name} to a another system`);\n\n      return false;\n    }\n\n    this._connectSystem(system);\n\n    return true;\n  }\n\n  _connectSystem(system) {\n    this._system = system; // must set system already here\n    // so that connect notifications \n    // compare systems correctly FIXME: think abou this\n\n    for (let c of this._components.values()) c._connectSystem(system);\n\n    for (let c of this._constraints.values()) if (c._danglingCount === 0) system.addConstraint(c);\n  }\n\n  disconnectSystem() {\n    if (this._system == null) {\n      _hdconsole.hdconsole.error(`Tried to disconnect a component ${this._name} that is already disconnected`);\n\n      return false;\n    }\n\n    if (this._owner != null) {\n      _hdconsole.hdconsole.error(`Tried to disconnect a subcomponent ${this._name} when owner is still connected`);\n\n      return false;\n    }\n\n    this._disconnectSystem();\n\n    return true;\n  }\n\n  _disconnectSystem() {\n    for (let c of this._components.values()) c._disconnectSystem();\n\n    for (let c of this._constraints.values()) this._system.removeConstraint(c); // cast OK since we know system is connected\n\n\n    this._system = null;\n  }\n\n  addComponent(c) {\n    if (c._owner != null) {\n      _hdconsole.hdconsole.error(`Tried to add component ${c._name} that already has an owner to component ${this._name}`);\n\n      return;\n    }\n\n    if (c._system != null) {\n      _hdconsole.hdconsole.error(`Tried to add to component ${this._name} the component ${c._name} that is connected to a system`);\n\n      return;\n    }\n\n    if (this._components.has(c._name)) {\n      _hdconsole.hdconsole.error(`Tried to add the component whose name ${c._name} already exists`);\n\n      return;\n    }\n\n    c._owner = this;\n\n    this._components.set(c._name, c);\n\n    if (this._system != null) c.connectSystem(this._system);\n  }\n\n  emplaceVariable(n, v) {\n    _hdconsole.hdconsole.assert(!this._varRefs.has(n), `Trying to add variable ${n} twice to component ${this._name}`);\n\n    let vr = mkVariable(this, v);\n\n    this._varRefs.set(n, vr);\n\n    this._varRefNames.set(vr, n);\n\n    this._vars.add(vr.value); // cast ok, vr is an owning reference\n\n\n    let name = \"__stay__\" + n;\n    let c = new Constraint(this, stayConstraintSpec, [vr], true);\n\n    this._constraints.set(name, c);\n\n    this._constraintNames.set(c, name);\n\n    return vr;\n  }\n\n  emplaceVariableReference(n) {\n    _hdconsole.hdconsole.assert(!this._varRefs.has(n), `Trying to add variable reference ${n} twice to component ${this._name}`);\n\n    let vr = new VariableReference(this);\n\n    this._varRefs.set(n, vr);\n\n    this._varRefNames.set(vr, n);\n\n    return vr;\n  }\n\n  emplaceConstraint(n, cspec, vrefs, optional = false) {\n    let c = new Constraint(this, cspec, vrefs, optional);\n    if (n == null) n = this._nextFreshConstraintName();\n    if (this._constraints.has(n)) throw `Constraint ${n} already exists in component ${this._name}`;\n\n    this._constraints.set(n, c);\n\n    this._constraintNames.set(c, n);\n\n    return c;\n  }\n\n  _nextFreshConstraintName() {\n    return \"c#\" + this._nextFreshCIndex++;\n  }\n\n  variableReferenceName(r) {\n    let s = this._varRefNames.get(r);\n\n    return s == null ? \"<unnamed>\" : s;\n  }\n\n  constraintName(c) {\n    return this._constraintNames.get(c);\n  }\n\n  getVariableReference(n) {\n    let r = this._varRefs.get(n);\n\n    if (r != null) return r;\n    if (this._owner == null) return undefined;\n    return this._owner.getVariableReference(n);\n  }\n\n  get vs() {\n    return new Proxy(this, {\n      get: function (target, property) {\n        return target._varRefs.get(property);\n      },\n      set: function (target, property, value, receiver) {\n        let r = target._varRefs.get(property);\n\n        if (r == null) {\n          _hdconsole.hdconsole.warn(`Linking an unknown variable ${property}`);\n\n          return false; // this causes a TypeError in strict mode\n        } else {\n          r.link(value);\n          return true;\n        }\n      }\n    });\n  }\n\n  get cs() {\n    return new Proxy(this, {\n      get: function (target, property) {\n        return target._constraints.get(property);\n      }\n    });\n  }\n\n  get components() {\n    return new Proxy(this, {\n      get: function (target, property) {\n        return target._components.get(property);\n      }\n    });\n  }\n\n}\n\nexports.Component = Component;\n\nfunction freshNameGenerator(prefix) {\n  let n = 0;\n  return () => prefix + n++;\n}\n\nconst freshComponentName = freshNameGenerator(\"comp#\");\nexports.freshComponentName = freshComponentName;\n\nfunction isOwnerOf(c1, c2) {\n  while (c1 !== c2) {\n    if (c2._owner == null) return false;else c2 = c2._owner;\n  }\n\n  return true;\n} // FIXME: these are hacks because of trouble with instanceof and babel\n\n\nfunction isConstraint(c) {\n  return c.hasOwnProperty(\"_cspec\");\n}\n\nfunction isVariable(v) {\n  return v.hasOwnProperty(\"_activation\");\n}\n\nfunction isMethod(v) {\n  return v.hasOwnProperty(\"_promiseMask\");\n}\n\nclass Constraint {\n  // used in pruning\n  // used in pruning\n  // used in pruning\n  prettyPrint() {\n    let s = \"constraint \" + this.name + \" {\\n\";\n    s += \"  \";\n\n    for (let vr of this._varRefs) s += vr.prettyPrint() + \"; \";\n\n    s += \"\\n\";\n    s += this._cspec.prettyPrint(\"  \", this._varRefs);\n    s += \"}\\n\";\n    return s;\n  }\n\n  substitute(vrs) {\n    return new Constraint(this._owner, this._cspec, vrs, this._optional);\n  }\n\n  constructor(owner, cspec, vrefs, optional = false) {\n    this._owner = owner;\n    this._cspec = cspec;\n    this._varRefs = [];\n    this._vars = Array(cspec.nvars).fill(null);\n    this._used = Array(cspec.nvars).fill(true); // FIXME: this is probably not used anymore\n\n    this._danglingCount = cspec.nvars;\n    this._optional = optional; // _vars is only used when all refs are resolved\n\n    this._indices = new Map();\n    let i = 0;\n\n    for (let r of vrefs) {\n      _hdconsole.hdconsole.assert(isOwnerOf(r._owner, this._owner), `Constructing constraint ${this.name} with a foreign variable reference`);\n\n      this._varRefs[i] = r;\n      {\n        let index = i; // for correct scoping\n\n        r.subscribe(v => {\n          if (v !== null) {\n            // connect\n            if (this._vars[index] !== null) console.log(\"NOTNULL\", this._vars[index]); // FIXME: is this necessary still?\n\n            this._vars[index] = v;\n\n            this._indices.set(v, index);\n\n            if (--this._danglingCount == 0) {\n              let s = this.system;\n              if (s != null) s.addConstraint(this);\n            }\n          } else {\n            // disconnect\n            if (this._vars[index] === null) return; // already disconnected\n\n            if (this._danglingCount++ == 0) {\n              let s = this.system;\n              if (s != null) s.removeConstraint(this);\n            }\n\n            this._indices.delete(this._vars[index]);\n\n            this._vars[index] = null;\n          }\n        });\n      }\n      ++i;\n    }\n\n    this._initPruningData();\n\n    this.clearSelectedMethod();\n  }\n\n  equals(c) {\n    return this === c;\n  }\n\n  get name() {\n    return this._owner == null ? \"<unnamed>\" : this._owner.constraintName(this);\n  }\n\n  get nvars() {\n    return this._cspec.nvars;\n  }\n\n  get system() {\n    return this._owner.system;\n  }\n\n  i2v(i) {\n    return this._vars[i];\n  }\n\n  v2i(v) {\n    _hdconsole.hdconsole.assert(this._indices.has(v), \"unknown variable in Constraint.v2i: \" + v.name);\n\n    return this._indices.get(v);\n  }\n\n  variables() {\n    return this._vars;\n  }\n\n  outs(m) {\n    return m.vOuts(this._vars);\n  }\n\n  ins(m) {\n    return m.vIns(this._vars);\n  }\n\n  nonOuts(m) {\n    return m.vNonOuts(this._vars);\n  }\n\n  methods() {\n    return this._cspec.methods();\n  }\n\n  hasMethod(m) {\n    return this._cspec.hasMethod(m);\n  }\n\n  viableMethods() {\n    return this._viableMethods;\n  }\n\n  get selectedMethod() {\n    return this._selectedMethod;\n  }\n\n  set selectedMethod(m) {\n    _hdconsole.hdconsole.assert(this._cspec.hasMethod(m), \"selecting a method not in the constraint\");\n\n    this._selectedMethod = m;\n\n    for (let i of m.ins()) this._used[i] = true;\n  }\n\n  clearSelectedMethod() {\n    this._selectedMethod = null;\n  }\n\n  isEnforced() {\n    return this._selectedMethod != null;\n  }\n\n  isOutputVariable(v) {\n    if (this.selectedMethod == null) return false;else return this.selectedMethod.isOut(this.v2i(v));\n  }\n\n  isInputVariable(v) {\n    if (this.selectedMethod == null) return false;else return this.selectedMethod.isIn(this.v2i(v));\n  }\n\n  isNonOutputVariable(v) {\n    if (this.selectedMethod == null) return false;else return this.selectedMethod.isNonOut(this.v2i(v));\n  }\n\n  downstreamVariables() {\n    if (this.selectedMethod == null) return util.mkEmptyIterable();else return this.selectedMethod.vOuts(this._vars);\n  }\n\n  downstreamAndUndetermined() {\n    if (this.selectedMethod == null) return this._vars;else return this.selectedMethod.vOuts(this._vars);\n  }\n\n  upstreamVariables() {\n    if (this.selectedMethod == null) return util.mkEmptyIterable();else return this.selectedMethod.vNonOuts(this._vars);\n  }\n\n  upstreamAndUndetermined() {\n    if (this.selectedMethod == null) return this._vars;else return this.selectedMethod.vNonOuts(this._vars);\n  }\n\n  _initPruningData() {\n    this._viableMethods = new Set();\n    this._forcedVariables = new Set();\n    this._outCounts = Array(this.nvars).fill(0);\n\n    for (let m of this.methods()) {\n      this._viableMethods.add(m);\n\n      for (let i of m.outs()) this._outCounts[i] += 1;\n    }\n\n    const vmcount = this._viableMethods.size;\n\n    for (let i = 0; i < this.nvars; ++i) {\n      if (this._outCounts[i] === vmcount) this._forcedVariables.add(i);\n    }\n  }\n\n  _makeMethodViable(m) {\n    _hdconsole.hdconsole.assert(!this._viableMethods.has(m), \"making a method viable twice\");\n\n    _hdconsole.hdconsole.assert(this.hasMethod(m), \"unknown method\");\n\n    let vmcountOld = this._viableMethods.size;\n\n    this._viableMethods.add(m);\n\n    let newlyUnforced = [];\n\n    for (let i of m.outs()) this._outCounts[i] += 1;\n\n    for (let i of m.nonOuts()) {\n      if (this._outCounts[i] === vmcountOld) {\n        this._forcedVariables.delete(i);\n\n        newlyUnforced.push(i);\n      }\n    }\n\n    return newlyUnforced;\n  } // returns the indices of the newly forced variables\n\n\n  _makeMethodNonviable(m) {\n    _hdconsole.hdconsole.assert(this._viableMethods.has(m), \"making a method nonviable twice\");\n\n    _hdconsole.hdconsole.assert(this._viableMethods.size >= 2, \"trying to make the last viable method nonviable\");\n\n    this._viableMethods.delete(m);\n\n    let vmcount = this._viableMethods.size;\n    let newlyForced = [];\n\n    for (let i of m.outs()) this._outCounts[i] -= 1;\n\n    for (let i of m.nonOuts()) {\n      if (this._outCounts[i] === vmcount) {\n        this._forcedVariables.add(i);\n\n        newlyForced.push(i);\n      }\n    } // FIXME: remove at some point\n\n\n    for (let i = 0; i < this._outCounts.length; ++i) _hdconsole.hdconsole.assert(this._outCounts[i] >= 0);\n\n    return newlyForced;\n  }\n\n  _makeMethodsNonviableByVariable(v) {\n    let vi = this.v2i(v);\n    if (this._forcedVariables.has(vi)) return util.mkEmptyIterable();\n    let newlyForced = new Set();\n\n    for (let m of util.filter(m => m.isOut(vi), this._viableMethods)) {\n      for (let vv of util.map(v => this.i2v(v), this._makeMethodNonviable(m))) {\n        newlyForced.add(vv);\n      }\n    }\n\n    return newlyForced;\n  }\n\n}\n\nexports.Constraint = Constraint;\n\nclass ConstraintSystem {\n  // FIXME: move to a better place\n  allConstraints() {\n    return util.join([this._musts, this._optionals.entries()]);\n  }\n\n  addComponent(c) {\n    return c.connectSystem(this);\n  }\n\n  removeComponent(c) {\n    if (c.system != this) {\n      console.warn(`Tried to remove component ${c._name} from a constraint system in which it does not exist.`);\n      return false;\n    }\n\n    return c.disconnectSystem();\n  }\n\n  prettyPrint() {\n    let s = \"-- musts --\\n\";\n\n    for (let m of this._musts) s += m.prettyPrint();\n\n    s += \"-- optionals --\\n\";\n\n    for (let m of this._optionals.entries()) s += m.prettyPrint();\n\n    return s;\n  }\n\n  constructor() {\n    this._optionals = new util.PriorityList();\n    this._musts = new Set();\n    this._dirty = new Set();\n    this._v2cs = new util.OneToManyMap();\n    this._usg = new UpstreamSolutionGraph(this);\n    this._dsg = new DownstreamSolutionGraph(this);\n  }\n\n  update() {\n    this.plan(this.allConstraints()); // FIXME: a little wasteful since plan iterates\n    // all vars of all constraints, and same vars appear many time. OK for now\n\n    this.solveFromConstraints(this.allConstraints());\n  }\n\n  variables() {\n    return this._v2cs.keys();\n  }\n\n  constraints(v) {\n    return this._v2cs.values(v);\n  }\n\n  *allConstraints() {\n    for (let c of this._musts) yield c;\n\n    for (let c of this._optionals.entries()) yield c;\n  }\n\n  isMust(c) {\n    return this._musts.has(c);\n  }\n\n  isOptional(c) {\n    return !this._musts.has(c);\n  }\n\n  addConstraint(c) {\n    for (let v of c.variables()) this._v2cs.add(v, c);\n\n    if (c._optional) this._optionals.pushBack(c);else this._musts.add(c);\n\n    this._dirty.add(c);\n  }\n\n  removeConstraint(c) {\n    for (let v of c.variables()) {\n      this._v2cs.remove(v, c);\n\n      if (this._v2cs.count(v) == 0) this._v2cs.removeKey(v);\n    }\n\n    if (c._optional) this._optionals.remove(c);else this._musts.delete(c);\n\n    this._dirty.delete(c);\n  }\n\n  setDirty(c) {\n    this._dirty.add(c);\n  }\n\n  gatherUpstreamConstraints(vs) {\n    let r = util.filter(v => isConstraint(v), (0, _graphAlgorithms.reverseTopoSortFrom)(this._usg, vs));\n    return r; // cast is to shut up flowtype\n  }\n\n  gatherDownstreamConstraints(vs) {\n    let r = util.filter(v => isConstraint(v), (0, _graphAlgorithms.reverseTopoSortFrom)(this._dsg, vs));\n    return r;\n  }\n\n  gatherDownstreamVariables(vs) {\n    let r = util.filter(v => isVariable(v), (0, _graphAlgorithms.reverseTopoSortFrom)(this._dsg, vs));\n    return r;\n  }\n\n  promoteVariable(v) {\n    this.promoteConstraint(this.getStay(v));\n  }\n\n  promoteConstraint(c) {\n    this._optionals.promote(c);\n  }\n\n  demoteConstraint(c) {\n    this._optionals.demote(c);\n  }\n\n  strength(c) {\n    if (this.isMust(c)) return this._optionals.highestPriority + 1;else return this._optionals.priority(c);\n  }\n\n  getStay(v) {\n    for (let c of this._v2cs.values(v)) {\n      if (c.name == \"__stay__\" + v.name) return c;\n    }\n\n    _hdconsole.hdconsole.assert(false, \"Variable's stay constraint does not exists\");\n\n    return null;\n  }\n\n  planDirty() {\n    return this.plan(this._dirty);\n  }\n\n  updateDirty() {\n    this.planDirty();\n    this.executeDirty();\n\n    this._dirty.clear();\n  }\n\n  plan(toEnforce) {\n    let vs = util.join(util.map(c => c.variables(), toEnforce)); // all variables from all constraints in the enforce queues\n\n    let constraintsThatNeedNewPlan = this.gatherUpstreamConstraints(vs); // gather all constraints upstream from these variables.\n    // This includes all constraints reachable through any method \n    // of an unenforced constraint. Quickplan does not do this since\n    // it has a separate reenforcing phase, but we put all constraints\n    // that may need to change into one bunch.\n    // The point is that unenforced constraints may become enforceable,\n    // and then they may force resolving of their upstream constraints.\n\n    let enforceable = new Set(); // this is the set of constraints that is determined to be enforceable\n\n    let forcedSet = new Set(); // this is the set of variables that are forced with the enforceable\n    // methods\n\n    let opts = new util.BinaryHeap((c1, c2) => this.strength(c1) > this.strength(c2)); // initialize simple planner with all must constraints (should be enforceable)\n\n    let sp = new SimplePlanner();\n    util.forEach(c => {\n      c.clearSelectedMethod();\n\n      c._initPruningData(); // FIXME: maybe just make methods viable again\n\n\n      if (this.isMust(c)) {\n        enforceable.add(c);\n        sp.addConstraint(c);\n      } else {\n        opts.push(c);\n      }\n    }, constraintsThatNeedNewPlan); // \n\n    _hdconsole.hdconsole.assert(sp.plan(), \"no plan for must constraints\"); // the conflicting constraints are in sp.constraints()\n\n\n    while (!opts.empty()) {\n      let opt = opts.pop();\n\n      switch (sp.extendPlanIfPossible(opt, forcedSet)) {\n        case false:\n          break;\n\n        case true:\n          enforceable.add(opt);\n\n          this._prune(opt, enforceable, forcedSet);\n\n          break;\n\n        case null:\n          sp.clear();\n\n          for (let c of enforceable) {\n            //            c.clearSelectedMethod();\n            sp.addConstraint(c);\n          }\n\n          sp.addConstraint(opt);\n\n          if (sp.plan()) {\n            enforceable.add(opt);\n\n            this._prune(opt, enforceable, forcedSet);\n          } else {\n            sp.removeConstraint(opt);\n            opt.clearSelectedMethod();\n            sp.undoChangesAfterFailedPlan();\n          }\n\n          break;\n      }\n    }\n\n    return enforceable;\n  } // prune starting from constraint c\n\n\n  _prune(c, constraintsOfInterest, forcedSet) {\n    let inspected = new Set(); // initialize worklist with the variables that c forces\n\n    let worklist = Array.from(c._forcedVariables, i => c.i2v(i));\n\n    while (worklist.length > 0) {\n      let v = worklist.pop();\n      inspected.add(v);\n      if (forcedSet.has(v)) continue;\n      forcedSet.add(v); // inspect all constraints connected to v\n\n      for (let cn of this.constraints(v)) {\n        if (!cn.isEnforced()) continue;\n        if (!constraintsOfInterest.has(cn)) continue;\n\n        for (let vv of cn._makeMethodsNonviableByVariable(v)) {\n          // vv iterates over the set of newly forced variables\n          if (!inspected.has(vv)) {\n            worklist.push(vv);\n          }\n        }\n      }\n    }\n  }\n\n  solveFromConstraints(cs) {\n    this.solve(util.join(util.map(c => c.downstreamVariables(), cs)));\n  }\n\n  solve(vs) {\n    let cs = [];\n\n    for (let v of vs) {\n      let c = this.getSourceConstraint(v);\n      if (c != null) cs.push(c);\n    } // Find the constraints that write to variables in vs.\n    // Usually these are stay constraints, but could be other constraints if the\n    // variable cannot stay in the chosen plan\n    // NOTE: every variable must have a stay or other constraint that writes to it. Otherwise\n    // constraints downstream from it are not found.\n\n\n    let dsc = Array.from(this.gatherDownstreamConstraints(cs)).reverse();\n\n    for (let c of dsc) this.scheduleConstraint(c);\n  }\n\n  executeDirty() {\n    let dsc = Array.from(this.gatherDownstreamConstraints(this._dirty)).reverse();\n\n    for (let c of dsc) this.scheduleConstraint(c);\n  }\n\n  getSourceConstraint(v) {\n    for (let c of this._v2cs.values(v)) {\n      if (c.isOutputVariable(v)) return c;\n    }\n\n    return null;\n  }\n\n  scheduleConstraint(c) {\n    if (!c.isEnforced()) return; // if there is no selected method, there  is nothing to schedule\n\n    let m = c.selectedMethod;\n    let inDeferreds = Array.from(c.ins(m), v => v._activation); // push new activations to all outputs, but remember the previous onces\n\n    let prevActs = [];\n    util.forEach(v => {\n      prevActs.push(v._activation);\n      v.pushNewActivation();\n    }, c.outs(m));\n    let outDeferreds = Array.from(c.outs(m), v => v._activation);\n    new _computationGraph.MethodActivation(m.code, m._promiseMask).execute(inDeferreds, outDeferreds); // only release the old activations of outputs here; after a new method activation has been executed                     \n\n    util.forEach(v => util.release(v), prevActs);\n  } // touch order is fixed, last parameter gets highest\n\n\n  scheduleCommand(ins, outs, f) {\n    let inDeferreds = Array.from(ins, v => v._activation);\n    let outArray = Array.from(outs); // push new activations to all outputs, but remember the previous onces\n\n    let prevActs = [];\n    util.forEach(v => {\n      prevActs.push(v._activation);\n      v.pushNewActivation();\n    }, outArray);\n    let outDeferreds = Array.from(outArray, v => v._activation);\n    new _computationGraph.MethodActivation(f, Array(inDeferreds.length).fill(false)).execute(inDeferreds, outDeferreds); // only release the old activations of outputs here; after a new method activation has been executed                     \n\n    util.forEach(v => util.release(v), prevActs);\n    outArray.forEach(v => this.promoteVariable(v));\n    let enforceable = this.plan(util.map(v => this.getStay(v), outArray));\n    this.solve(outArray);\n  }\n\n}\n\nexports.ConstraintSystem = ConstraintSystem;\n\nclass DownstreamSolutionGraph {\n  constructor(system) {\n    this._system = system;\n  }\n\n  adjacentOutVertices(v) {\n    if (isConstraint(v)) {\n      return v.downstreamAndUndetermined();\n    } else return util.filter(c => c.isNonOutputVariable(v) || !c.isEnforced(), this._system._v2cs.values(v));\n  }\n\n  outDegree(v) {\n    if (isConstraint(v)) {\n      return v.selectedMethod != null ? v.selectedMethod.nOuts() : 0;\n    } else {\n      return util.count(this.adjacentOutVertices(v)); // not constant time\n    }\n  }\n\n}\n\nexports.DownstreamSolutionGraph = DownstreamSolutionGraph;\n\nclass UpstreamSolutionGraph {\n  constructor(system) {\n    this._system = system;\n  }\n\n  adjacentOutVertices(v) {\n    if (isConstraint(v)) {\n      return v.upstreamAndUndetermined();\n    } else return util.filter(c => c.isOutputVariable(v) || !c.isEnforced(), this._system._v2cs.values(v));\n  }\n\n  outDegree(v) {\n    if (isConstraint(v)) {\n      return v.selectedMethod != null ? v.selectedMethod.nNonOuts() : 0;\n    } else {\n      return util.count(this.adjacentOutVertices(v)); // not constant time\n    }\n  }\n\n}\n\nexports.UpstreamSolutionGraph = UpstreamSolutionGraph;\n\nclass SimplePlanner {\n  // record if selected method changes, so we can undo\n  // to a previous solution\n  constructor() {\n    this._v2cs = new util.OneToManyMap();\n    this._freeVars = new Set();\n    this._forcedByPlan = new Map();\n    this._changeList = [];\n  }\n\n  addConstraint(c) {\n    for (let v of c.variables()) {\n      this._v2cs.add(v, c);\n\n      switch (this._v2cs.count(v)) {\n        case 1:\n          this._freeVars.add(v);\n\n          break;\n\n        case 2:\n          this._freeVars.delete(v);\n\n          break;\n      }\n    }\n  }\n\n  removeConstraint(c) {\n    for (let v of c.variables()) {\n      this._v2cs.remove(v, c);\n\n      switch (this._v2cs.count(v)) {\n        case 0:\n          this._freeVars.delete(v);\n\n          this._v2cs.removeKey(v);\n\n          break;\n\n        case 1:\n          this._freeVars.add(v);\n\n          break;\n      }\n    }\n  }\n\n  clear() {\n    this._v2cs.clear();\n\n    this._freeVars.clear(); //    this._forcedByPlan.clear();\n\n  }\n\n  plan() {\n    let foundFree = true;\n\n    while (foundFree) {\n      foundFree = false;\n\n      for (let [c, m] of this.freeMethods()) {\n        foundFree = true;\n        let oldm = c.selectedMethod;\n\n        if (oldm !== m && oldm != null) {\n          this._changeList.push([c, oldm]);\n\n          for (let v of c.outs(oldm)) this._forcedByPlan.delete(v); // clear old methods forced by data\n\n        }\n\n        c.selectedMethod = m;\n\n        for (let v of c.outs(m)) this._forcedByPlan.set(v, m);\n\n        this.removeConstraint(c);\n      }\n    }\n\n    if (this._v2cs.countKeys() === 0) {\n      this._changeList = []; // no undo info after successful plan\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  undoChangesAfterFailedPlan() {\n    for (let [c, m] of this._changeList) {\n      let oldm = c.selectedMethod;\n\n      if (oldm != null) {\n        for (let v of c.outs(oldm)) this._forcedByPlan.delete(v);\n      }\n\n      for (let v of c.outs(m)) this._forcedByPlan.set(v, m);\n\n      c.selectedMethod = m;\n    }\n  }\n\n  extendPlanIfPossible(c, forcedSet) {\n    // FIXME: special case for stays for speed\n    if (util.every(m => util.some(v => forcedSet.has(v), c.outs(m)), c._viableMethods)) return false; // if every method has some output to a forced variable,\n    // the constraint is unenforceable\n\n    if (util.every(v => !this._forcedByPlan.has(v), c.variables())) {\n      let m = util.first(c._viableMethods); // just pick the first (likely only method) for the plan\n\n      _hdconsole.hdconsole.assert(m != null, \"constraint has no viable methods\");\n\n      if (m == null) return false; // FIXME: think if asserting is the best way: could just return false?\n\n      c.selectedMethod = m;\n\n      for (let v of c.outs(m)) {\n        this._forcedByPlan.set(v, m);\n      } // Methods that have an output to a forcedByPlan variable\n      // cannot be added to the plan. But methods that have\n      // nonOutputs that are forced, could lead to a cycle.\n      // So we ban all constraints that have have variables\n      // forced by the current plan. \n      // This could be detected, but instead we just say \n      // that it is unusure if plan is possible or not.\n      // The usual case\n      // of calling this function is with stay constraints,\n      // and then cycles are not an issue.\n\n\n      return true;\n    }\n\n    return null; // don't know if c can be enforced, must do planning\n  }\n\n  *freeMethods() {\n    let seen = new Set(); // check constraint only once\n\n    for (let v of this._freeVars) {\n      for (let c of this._v2cs.values(v)) {\n        // FIXME: this loop should only happen once, because v is free.\n        // right?\n        if (!seen.has(c)) {\n          seen.add(c);\n\n          for (let m of c.viableMethods()) {\n            if (util.every(v => this._freeVars.has(v), c.outs(m))) {\n              yield [c, m];\n              break; // only generate the first method per constraint\n            }\n          }\n        }\n      }\n    }\n  }\n\n  firstFreeMethod() {\n    return util.first(this.freeMethods());\n  }\n\n  constraints() {\n    let cs = new Set();\n\n    for (let v of this._v2cs.keys()) {\n      for (let c of this._v2cs.values(v)) cs.add(c);\n    }\n\n    return cs;\n  }\n\n}\n\nexports.SimplePlanner = SimplePlanner;\nconst stayConstraintSpec = new ConstraintSpec([new Method(1, [0], [0], [maskNone], a => a, \"stay\")]);\n\nfunction enforceStayMethod(stay) {\n  stay.selectedMethod = util.first(stay._cspec._methods);\n}\n\nfunction isStay(c) {\n  return c._cspec === stayConstraintSpec;\n}\n\n//# sourceURL=webpack://hd/./lib/constraint-system.js?");

/***/ }),

/***/ "./lib/graph-algorithms.js":
/*!*********************************!*\
  !*** ./lib/graph-algorithms.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reverseTopoSort = reverseTopoSort;\nexports.reverseTopoSortFrom = reverseTopoSortFrom;\nexports.dfsVisit = dfsVisit;\n\nvar _utilities = __webpack_require__(/*! ./utilities */ \"./lib/utilities.js\"); // export type { DfsAdjacencyVisitor };\n\n\nfunction dfsVisit(g, vs, visitor, visited) {\n  if (visited == null) visited = new Set();\n  let stack = [];\n  let it = (0, _utilities.iterableToIterator)(vs);\n\n  while (true) {\n    let n = it.next();\n\n    if (n.done) {\n      if (stack.length === 0) break; // returns\n\n      let v;\n      [v, it] = stack.pop();\n      visitor.finishVertex(v);\n      continue;\n    }\n\n    let v = n.value;\n\n    if (visited.has(v)) {\n      continue;\n    }\n\n    visitor.discoverVertex(v);\n    visited.add(v);\n    stack.push([v, it]);\n    it = (0, _utilities.iterableToIterator)(g.adjacentOutVertices(v));\n  }\n}\n\nfunction reverseTopoSort(g) {\n  return reverseTopoSortFrom(g, g.vertices());\n}\n\nclass TopoVisitor {\n  constructor() {\n    this.result = [];\n  }\n\n  discoverVertex(v) {}\n\n  finishVertex(v) {\n    this.result.push(v);\n  }\n\n}\n\nfunction reverseTopoSortFrom(g, vs) {\n  let vis = new TopoVisitor();\n  dfsVisit(g, vs, vis);\n  return vis.result;\n}\n\n//# sourceURL=webpack://hd/./lib/graph-algorithms.js?");

/***/ }),

/***/ "./lib/hdconsole.js":
/*!**************************!*\
  !*** ./lib/hdconsole.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HdError = exports.hdconsole = exports.HdConsole = void 0;\n\nvar util = _interopRequireWildcard(__webpack_require__(/*! ./utilities */ \"./lib/utilities.js\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nclass HdConsole {\n  constructor(name) {\n    this._name = name;\n    this.off();\n  }\n\n  off() {\n    this.log = (...args) => {};\n\n    this.warn = (...args) => {};\n\n    this.error = (...args) => {};\n\n    this.assert = (...args) => {};\n  }\n\n  errorsOnly() {\n    this.off();\n    this.error = console.error;\n    this.assert = console.assert;\n  }\n\n  on() {\n    this.log = console.log;\n    this.warn = console.warn;\n    this.error = console.error;\n    this.assert = console.assert;\n  }\n\n}\n\nexports.HdConsole = HdConsole;\nvar hdconsole = new HdConsole(\"HotDrink\");\nexports.hdconsole = hdconsole;\n\nclass HdError extends Error {\n  constructor(msg, ...params) {\n    super(msg, ...params); // Maintains proper stack trace for where our error was thrown (only available on V8)\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, HdError);\n    }\n\n    this.name = 'HdError';\n  }\n\n}\n\nexports.HdError = HdError;\n\n//# sourceURL=webpack://hd/./lib/hdconsole.js?");

/***/ }),

/***/ "./lib/hotdrink.js":
/*!*************************!*\
  !*** ./lib/hotdrink.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  defaultConstraintSystem: true,\n  constraintSystemInVisNodesAndEdges: true,\n  constraintSystemInVisAllNodesAndEdges: true,\n  component: true,\n  hdl: true\n};\nexports.constraintSystemInVisNodesAndEdges = constraintSystemInVisNodesAndEdges;\nexports.constraintSystemInVisAllNodesAndEdges = constraintSystemInVisAllNodesAndEdges;\nObject.defineProperty(exports, \"component\", {\n  enumerable: true,\n  get: function () {\n    return _constraintBuilder.component;\n  }\n});\nObject.defineProperty(exports, \"hdl\", {\n  enumerable: true,\n  get: function () {\n    return _constraintBuilder.hdl;\n  }\n});\nexports.defaultConstraintSystem = void 0;\n\nvar _constraintSystem = __webpack_require__(/*! ./constraint-system.js */ \"./lib/constraint-system.js\");\n\nObject.keys(_constraintSystem).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _constraintSystem[key];\n    }\n  });\n});\n\nvar _constraintBuilder = __webpack_require__(/*! ./constraint-builder.js */ \"./lib/constraint-builder.js\"); // [[file:~/git/hd4/org/hotdrink.org::*Tangle][Tangle:1]]\n\n\nconst defaultConstraintSystem = new _constraintSystem.ConstraintSystem(); // [[file:~/git/hd4/org/hotdrink.org::visualization][visualization]]\n\nexports.defaultConstraintSystem = defaultConstraintSystem;\n\nlet objectId = (() => {\n  let m = new WeakMap();\n  let counter = 0;\n\n  let wm = o => {\n    let id = m.get(o);\n    if (id !== undefined) return id;else {\n      let curr = counter++;\n      m.set(o, curr);\n      return curr;\n    }\n  };\n\n  return wm;\n})();\n\nfunction constraintSystemInVisNodesAndEdges(cs) {\n  let nodes = [];\n  let edges = [];\n\n  for (let v of cs.variables()) {\n    nodes.push({\n      id: objectId(v),\n      label: v.name,\n      shape: 'box'\n    });\n  }\n\n  for (let c of cs.allConstraints()) {\n    let mcounter = 0;\n    if (!c.isEnforced()) continue;\n    let m = c.selectedMethod;\n    let id = `m#${objectId(c)}-${mcounter}`;\n    console.log(\"ID: \", id, \"C.M\", c.name + \".\" + m.name);\n    let color = 'lime';\n    nodes.push({\n      id: id,\n      label: c.name + \".\" + m.name,\n      cid: 'C#' + objectId(c),\n      color: color\n    });\n\n    for (let v of c.nonOuts(m)) edges.push({\n      from: objectId(v),\n      to: id,\n      arrows: 'to',\n      dashes: true\n    });\n\n    for (let v of c.outs(m)) edges.push({\n      from: id,\n      to: objectId(v),\n      arrows: 'to'\n    }); // FIXME: ins should be the complement of outs\n\n\n    ++mcounter;\n  }\n\n  return [nodes, edges];\n}\n\nfunction constraintSystemInVisAllNodesAndEdges(cs) {\n  let nodes = [];\n  let edges = [];\n\n  for (let v of cs.variables()) {\n    nodes.push({\n      id: objectId(v),\n      label: v.name,\n      shape: 'box'\n    });\n  }\n\n  for (let c of cs.allConstraints()) {\n    let mcounter = 0; //if (!c.isEnforced()) continue;\n\n    for (let m of c.methods()) {\n      let id = `m#${objectId(c)}-${mcounter}`;\n      console.log(\"ID: \", id, \"C.M\", c.name + \".\" + m.name);\n      let color = 'lime';\n      nodes.push({\n        id: id,\n        label: c.name + \".\" + m.name,\n        cid: 'C#' + objectId(c),\n        color: color\n      });\n\n      for (let v of c.nonOuts(m)) {\n        edges.push({\n          from: objectId(v),\n          to: id,\n          arrows: 'to',\n          dashes: true\n        });\n        console.log(\"INS: \", v.name);\n      }\n\n      for (let v of c.outs(m)) {\n        edges.push({\n          from: id,\n          to: objectId(v),\n          arrows: 'to'\n          /*, label: \"FROM_C_\"+c.name+\"_M_\"+m.name+\"+TO_\"+v.name*/\n\n        });\n        console.log(\"OUTS: \", v.name);\n      } // FIXME: ins should be the complement of outs\n\n\n      ++mcounter;\n    }\n  }\n\n  return [nodes, edges];\n} // visualization ends here\n// Tangle:1 ends here\n\n//# sourceURL=webpack://hd/./lib/hotdrink.js?");

/***/ }),

/***/ "./lib/observable.js":
/*!***************************!*\
  !*** ./lib/observable.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mkObserver = mkObserver;\nexports.BehaviorSubject = exports.ReplaySubject = exports.Subject = exports.SubscriptionObserver = exports.HdSubscription = exports.Observable = void 0; // [[file:~/git/hd4/org/observable.org::*Tangle][Tangle:1]]\n// [[file:~/git/hd4/org/observable.org::*Observer%20interface][]]\n// ends here\n// [[file:~/git/hd4/org/observable.org::*Subscription][]]\n// ends here\n// [[file:~/git/hd4/org/observable.org::*Subscription][]]\n// create an observer from separate functions\n\nfunction mkObserver(obs, err, complete) {\n  let observer;\n\n  if (typeof obs === 'function') {\n    observer = {};\n    observer.next = obs;\n    if (err != null) observer.error = err;\n    if (complete != null) observer.complete = complete;\n  } else observer = obs;\n\n  return observer;\n}\n\nclass Observable {\n  constructor(subscriber) {\n    this._subscriber = subscriber;\n  }\n\n  subscribe(obs, err, complete) {\n    let observer = mkObserver(obs, err, complete);\n    let subscription = new HdSubscription(observer);\n\n    try {\n      if (observer.start != null) observer.start(subscription);\n    } catch (e) {// FIXME: HostReportError(e)\n    }\n\n    if (subscription.closed) return subscription;\n    let subscriptionObserver = new SubscriptionObserver(subscription);\n\n    try {\n      let cleanup = this._subscriber(subscriptionObserver);\n\n      if (typeof cleanup === 'object') cleanup = () => cleanup.unsubscribe(); // must be a Subscription object\n\n      subscription._cleanup = cleanup;\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (subscription.closed) subscription.cleanup();\n    return subscription;\n  } // FIXME Implement later\n  // [Symbol.observable]() : Observable;\n\n\n  static of(...items) {\n    return new Observable(observer => {\n      for (let item of items) {\n        observer.next(item);\n        if (observer.closed) return;\n      }\n\n      observer.complete();\n    });\n  } // FIXME Implement later\n  // static from(obs: Observable<T> | Iterable<T>) : Observable<T> {\n  //   \n  // }   \n\n\n  filter(p) {\n    return new Observable(observer => {\n      let o = mkObserver(observer);\n      if (o.next == null) o = {\n        next: e => {}\n      };\n      let s = this.subscribe(e => {\n        if (p(e) == true) o.next(e);\n      });\n      return s;\n    });\n  }\n\n  map(f) {\n    return new Observable(observer => {\n      let o = mkObserver(observer);\n      if (o.next == null) o = {\n        next: e => {}\n      };\n      let s = this.subscribe(e => {\n        let o = mkObserver(observer);\n        o.next(f(e));\n      });\n      return s;\n    });\n  }\n\n}\n\nexports.Observable = Observable;\n\nclass HdSubscription {\n  constructor(observer) {\n    this._observer = observer;\n    this._cleanup = undefined;\n  }\n\n  unsubscribe() {\n    this._observer = undefined;\n    this.cleanup();\n  }\n\n  get closed() {\n    return this._observer === undefined;\n  }\n\n  cleanup() {\n    const cUp = this._cleanup;\n    if (cUp === undefined) return;\n    this._cleanup = undefined;\n\n    try {\n      cUp();\n    } catch (e) {\n      /* FIXME: HostReportErrors(e) */\n    }\n  }\n\n}\n\nexports.HdSubscription = HdSubscription;\n\nclass SubscriptionObserver {\n  constructor(s) {\n    this._subscription = s;\n  }\n\n  get closed() {\n    return this._subscription.closed;\n  }\n\n  next(value) {\n    let s = this._subscription; // appeasing flowtype\n\n    if (s.closed) return;\n\n    if (s._observer.next != null) {\n      try {\n        s._observer.next(value);\n      } catch (e) {\n        /* FIXME: HostReportErrors(e) */\n      }\n    }\n  }\n\n  error(errorValue) {\n    let s = this._subscription; // appeasing flowtype\n\n    if (s.closed) return; // FIXME, why not test this.closed ?\n\n    if (s._observer.error != null) {\n      try {\n        s._observer.error(errorValue);\n      } catch (e) {\n        /* FIXME: HostReportErrors(e) */\n      }\n    }\n\n    this._subscription.cleanup();\n  }\n\n  complete() {\n    let s = this._subscription; // appeasing flowtype\n\n    if (s.closed) return;\n\n    if (s._observer.complete != null) {\n      try {\n        s._observer.complete();\n      } catch (e) {\n        /* FIXME: HostReportErrors(e) */\n      }\n    }\n\n    this._subscription.cleanup();\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/observable.org::*Subjects][]]\n\n\nexports.SubscriptionObserver = SubscriptionObserver;\n\nclass Subject extends Observable {\n  constructor(f = o => {}) {\n    let state = {\n      observers: new Set(),\n      done: false\n    };\n    super(o => {\n      if (!state.done) state.observers.add(o);\n      f(o);\n      return () => state.observers.delete(o); // this is a no-op if done==true\n    });\n    this._subjectState = state;\n  }\n\n  sendNext(v) {\n    if (this._subjectState.done) return;\n\n    for (const obs of this._subjectState.observers) obs.next(v);\n  }\n\n  sendError(e) {\n    if (this._subjectState.done) return;\n    this._subjectState.done = true;\n\n    for (const obs of this._subjectState.observers) obs.error(e);\n  }\n\n  sendComplete() {\n    if (this._subjectState.done) return;\n    this._subjectState.done = true;\n\n    for (const obs of this._subjectState.observers) obs.complete();\n  }\n\n  get nObservers() {\n    return this._subjectState.observers.size;\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/observable.org::*Subjects][]]\n\n\nexports.Subject = Subject;\n\nclass ReplaySubject extends Subject {\n  constructor(limit = 1) {\n    let state = {\n      past: [],\n      pastLimit: limit,\n      isCompleted: false,\n      isError: false\n    };\n    super(o => {\n      for (let v of state.past) o.next(v);\n\n      if (state.isError) o.error(state.error);else if (state.isCompleted) o.complete();\n    });\n    this._replaySubjectState = state;\n  }\n\n  sendNext(v) {\n    this._replaySubjectState.past.push(v);\n\n    if (this._replaySubjectState.past.length > this._replaySubjectState.pastLimit) {\n      this._replaySubjectState.past.shift();\n    }\n\n    super.sendNext(v);\n  }\n\n  sendError(e) {\n    this._replaySubjectState.isError = true;\n    this._replaySubjectState.error = e;\n    super.sendError(e);\n  }\n\n  sendComplete() {\n    this._replaySubjectState.isCompleted = true;\n    super.sendComplete();\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/observable.org::*Subjects][]]\n\n\nexports.ReplaySubject = ReplaySubject;\n\nclass BehaviorSubject extends ReplaySubject {\n  constructor(v) {\n    super(1);\n\n    this._replaySubjectState.past.push(v);\n  }\n\n} // ends here\n// Tangle:1 ends here\n\n\nexports.BehaviorSubject = BehaviorSubject;\n\n//# sourceURL=webpack://hd/./lib/observable.js?");

/***/ }),

/***/ "./lib/utilities.js":
/*!**************************!*\
  !*** ./lib/utilities.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.equals = equals;\nexports.orderedSetEquals = orderedSetEquals;\nexports.orderedMapEquals = orderedMapEquals;\nexports.setEquals = setEquals;\nexports.mapEquals = mapEquals;\nexports.copy = copy;\nexports.subsetOf = subsetOf;\nexports.modifyMapValue = modifyMapValue;\nexports.setUnion = setUnion;\nexports.setUnionTo = setUnionTo;\nexports.setUnionToWithDiff = setUnionToWithDiff;\nexports.setDifference = setDifference;\nexports.setDifferenceTo = setDifferenceTo;\nexports.mkEmptyIterable = mkEmptyIterable;\nexports.mkSingletonIterable = mkSingletonIterable;\nexports.mkEmptyIterator = mkEmptyIterator;\nexports.iteratorToIterable = iteratorToIterable;\nexports.iterableToIterator = iterableToIterator;\nexports.map = map;\nexports.filter = filter;\nexports.until = until;\nexports.every = every;\nexports.some = some;\nexports.forEach = forEach;\nexports.adjacentFind = adjacentFind;\nexports.isSortedBy = isSortedBy;\nexports.count = count;\nexports.first = first;\nexports.firstKeepOpen = firstKeepOpen;\nexports.rest = rest;\nexports.foldl = foldl;\nexports.join = join;\nexports.zipWith = zipWith;\nexports.zip = zip;\nexports.bisimilar = bisimilar;\nexports.bisame = bisame;\nexports.every2 = every2;\nexports.sameElements = sameElements;\nexports.mkRefCounted = mkRefCounted;\nexports.setUniqueHandler = setUniqueHandler;\nexports.retain = retain;\nexports.release = release;\nexports.refCount = refCount;\nexports.isUnique = isUnique;\nexports.throw_on_null = throw_on_null;\nexports.nonnull_cast = nonnull_cast;\nexports.BinaryHeap = exports.ObservableReference = exports.PriorityList = exports.LinkedList = exports.ListNode = exports.RefListNode = exports.RefList = exports.OneToManyMap = void 0;\n\nvar _hdconsole = __webpack_require__(/*! ./hdconsole.js */ \"./lib/hdconsole.js\");\n\nvar Obs = _interopRequireWildcard(__webpack_require__(/*! ./observable.js */ \"./lib/observable.js\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n} // [[file:~/git/hd4/org/utilities.org::*Tangle][Tangle:1]]\n// [[file:~/git/hd4/org/utilities.org::*Equality][]]\n\n\nfunction equals(a, b) {\n  a = a;\n  b = b;\n  if (a === b) return true;\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n\n    for (let i = 0; i < a.length; ++i) if (!equals(a[i], b[i])) return false;\n\n    return true;\n  }\n\n  if (a instanceof Set && b instanceof Set) return orderedSetEquals(a, b); // Equality of keys is by ===, not by equals\n\n  if (a instanceof Map && b instanceof Map) return orderedMapEquals(a, b);\n\n  if (typeof a === 'object' && a !== null) {\n    // for any other kind of object (even function object)\n    // find .equals method if one exists\n    if (typeof a.equals === 'function') return a.equals(b);else if (b != null) {\n      // otherwise recurse through all members\n      let ak = Object.keys(a),\n          bk = Object.keys(b);\n      if (ak.length !== bk.length) return false;\n\n      for (let m of ak) if (!equals(a[m], b[m])) return false;\n\n      return true;\n    }\n  }\n\n  if (typeof a === 'function' && typeof a.equals === 'function') return a.equals(b); // by default functions are the same only if === says so; but if a function object has\n  // the equals member, then that member determines equality\n\n  return false;\n} // two ordered Sets are equal if they have the same keys in the same order\n\n\nfunction orderedSetEquals(s1, s2) {\n  if (s1.size !== s2.size) return false;\n  return bisame(s1, s2);\n} // two ordered Maps are equal if they have the same keys, in the same\n// order, and for each key, values are equal\n\n\nfunction orderedMapEquals(s1, s2) {\n  if (s1.size !== s2.size) return false;\n  return every2(([key1, value1], [key2, value2]) => key1 === key2 && equals(value1, value2), s1, s2);\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Set%20and%20Map%20equals%20---%20unordered][]]\n// two Sets are `set equal' if they have the same keys\n\n\nfunction setEquals(s1, s2) {\n  if (s1.size !== s2.size) return false;\n\n  for (let k of s1.keys()) if (!s2.has(k)) return false;\n\n  return true;\n} // two Maps are `set equal' if they have the same keys and for each key, values are equal\n\n\nfunction mapEquals(s1, s2) {\n  if (s1.size !== s2.size) return false;\n\n  for (let [k, v] of s1) {\n    if (!equals(s2.get(k), v)) return false;\n  }\n\n  return true;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Copy][]]\n\n\nfunction copy(a) {\n  return _copy(a);\n}\n\nfunction _copy(a) {\n  if (Array.isArray(a)) return a.map(v => copy(v));\n  if (a instanceof Set) return new Set(a);\n  if (a instanceof Map) return new Map(map(([k, v]) => [k, copy(v)], a));\n\n  if (typeof a === 'object' && a !== null) {\n    if (typeof a.copy === 'function') return a.copy();else {\n      let b = Object.create(Object.getPrototypeOf(a));\n\n      for (let m of Object.keys(a)) b[m] = copy(a[m]);\n\n      return b;\n    }\n  }\n\n  if (typeof a === 'function' && typeof a.copy === 'function') return a.copy(); // here should be a value, or something that is shared by reference\n\n  return a;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Subset][]]\n\n\nfunction subsetOf(sub, sup) {\n  for (let k of sub.keys()) if (!sup.has(k)) return false;\n\n  return true;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Apply%20a%20function%20over%20a%20value%20of%20a%20specific%20key][]]\n\n\nfunction modifyMapValue(m, k, fn) {\n  let newv = fn(m.get(k));\n  m.set(k, newv);\n  return newv;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Set%20union][]]\n\n\nfunction setUnion(s1, s2) {\n  let s = new Set();\n  setUnionTo(s, s1);\n  setUnionTo(s, s2);\n  return s;\n}\n\nfunction setUnionTo(s1, s2) {\n  for (let v of s2) s1.add(v);\n}\n\nfunction setUnionToWithDiff(s1, s2) {\n  let diff = new Set();\n\n  for (let v of s2) if (!s1.has(v)) {\n    s1.add(v);\n    diff.add(v);\n  }\n\n  return diff;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Set%20difference][]]\n\n\nfunction setDifference(s1, s2) {\n  let s = new Set();\n\n  for (let v of s1) if (!s2.has(v)) s.add(v);\n\n  return s;\n}\n\nfunction setDifferenceTo(s1, s2) {\n  for (let v of s2) s1.delete(v);\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Constructing%20iterables][]]\n\n\nfunction* mkEmptyIterable() {}\n\nfunction* mkSingletonIterable(v) {\n  yield v;\n}\n\nfunction mkEmptyIterator() {\n  // flowtype wants iterators to have @@iterator, which is an iterable's method,\n  // and does not need to be in iterator. To appease flowtype,\n  // we define a dummy in flowtype-comments\n  return {\n    /*:: @@iterator(): Iterator<T> { return ({}: any); }, */\n    // $FlowFixMe: computed property\n    next: () => ({\n      done: true,\n      value: undefined\n    })\n  };\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Constructing%20iterables][]]\n\n\nfunction iteratorToIterable(it) {\n  let v = {};\n\n  v[Symbol.iterator] = function () {\n    return it;\n  };\n\n  return v; //    return ({ [Symbol.iterator]: () => it }: any);\n}\n\nfunction iterableToIterator(it) {\n  return it[Symbol.iterator]();\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*map%20and%20filter][]]\n\n\nfunction map(fn, iterable) {\n  return {\n    [Symbol.iterator]: () => {\n      const iterator = iterable[Symbol.iterator]();\n      let mapIterator = {};\n\n      mapIterator.next = () => {\n        const {\n          done,\n          value\n        } = iterator.next();\n        return {\n          done,\n          value: done ? undefined : fn(value)\n        };\n      };\n\n      if (typeof iterator.return === 'function') {\n        mapIterator.return = v => {\n          return iterator.return(v);\n        };\n      }\n\n      ;\n\n      if (typeof iterator.throw === 'function') {\n        mapIterator.throw = e => {\n          return iterator.throw(e);\n        }; // assuming that if .throw throws, iterator relases resources, sets itself closed etc.\n\n      }\n\n      ;\n      return mapIterator;\n    }\n  };\n}\n\nfunction filter(fn, iterable) {\n  return {\n    [Symbol.iterator]: () => {\n      const iterator = iterable[Symbol.iterator]();\n      let filterIterator = {};\n\n      filterIterator.next = () => {\n        let done = false;\n        let value = undefined;\n\n        do {\n          ({\n            done,\n            value\n          } = iterator.next());\n        } while (!done && !fn(value));\n\n        return {\n          done,\n          value\n        };\n      };\n\n      if (typeof iterator.return === 'function') {\n        filterIterator.return = v => {\n          return iterator.return(v);\n        };\n      }\n\n      ;\n\n      if (typeof iterator.throw === 'function') {\n        filterIterator.throw = e => {\n          return iterator.throw(e);\n        }; // assuming that if .throw throws, iterator relases resources, sets itself closed etc.\n\n      }\n\n      ;\n      return filterIterator;\n    }\n  };\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Until][]]\n\n\nfunction until(fn, iterable) {\n  return {\n    [Symbol.iterator]: () => {\n      const iterator = iterable[Symbol.iterator]();\n      let untilIterator = {};\n\n      let step = () => iterator.next();\n\n      untilIterator.done = false;\n\n      untilIterator.next = () => {\n        if (untilIterator.done) return {\n          done: true\n        };\n        let {\n          done,\n          value\n        } = step();\n\n        step = () => iterator.next();\n\n        if (done) {\n          // normal closing of iterator: assuming it releases resources \n          untilIterator.done = true;\n          return {\n            done: true\n          };\n        }\n\n        done = fn(value);\n\n        if (done) {\n          if (typeof iterator.return === 'function') iterator.return(); // call return to release resources\n\n          return {\n            done: true\n          };\n        } else {\n          return {\n            done: false,\n            value: value\n          };\n        }\n      };\n\n      if (typeof iterator.return === 'function') {\n        untilIterator.return = v => {\n          return iterator.return(v);\n        };\n      }\n\n      ;\n\n      if (typeof iterator.throw === 'function') {\n        untilIterator.throw = e => {\n          step = () => iterator.throw(e);\n\n          return untilIterator.next(); // we do not catch exceptions and call iterator.return; assuming that\n          // if iterator.throw throws, iterator releases resources \n        };\n      }\n\n      ;\n      return untilIterator;\n    }\n  };\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Every%20and%20some][]]\n\n\nfunction every(fn, iterable) {\n  for (let i of iterable) if (!fn(i)) return false;\n\n  return true;\n}\n\nfunction some(fn, iterable) {\n  for (let i of iterable) if (fn(i)) return true;\n\n  return false;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*forEach][]]\n\n\nfunction forEach(fn, iterable) {\n  for (let i of iterable) fn(i);\n\n  return fn;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Adjacent%20find][]]\n\n\nfunction adjacentFind(cmp, iterable) {\n  let iter = iterableToIterator(iterable);\n  let r = iter.next();\n  if (r.done) return null;\n  let prevVal = r.value;\n\n  while (true) {\n    let curr = iter.next();\n    if (curr.done) return null;\n\n    if (cmp(prevVal, curr.value)) {\n      if (typeof iter.return === 'function') iter.return(); // release resources\n      // FIXME: how to convince flowtype that return may exist?\n\n      return [prevVal, curr.value];\n    } else {\n      prevVal = curr.value;\n    }\n  }\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Adjacent%20find][]]\n\n\nfunction isSortedBy(cmp, iterable) {\n  return adjacentFind((a, b) => !cmp(a, b), iterable) === null;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Count%20elements][]]\n\n\nfunction count(iterable) {\n  let i = 0;\n\n  for (let _ of iterable) ++i;\n\n  return i;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*First%20and%20rest][]]\n\n\nfunction first(iterable) {\n  const iterator = iterable[Symbol.iterator]();\n  let r = iterator.next();\n  if (r.done) return undefined;else {\n    if (typeof iterator.return === 'function') iterator.return();\n    return r.value;\n  }\n}\n\nfunction firstKeepOpen(iterable) {\n  let r = iterable[Symbol.iterator]().next();\n  if (r.done) return undefined;else return r.value;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*First%20and%20rest][]]\n\n\nfunction rest(iterable) {\n  let iterator = iterableToIterator(iterable);\n  iterator.next();\n  return iteratorToIterable(iterator);\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Foldl][]]\n\n\nfunction foldl(fn, u, iterable) {\n  let acc = u;\n\n  for (let t of iterable) acc = fn(t, acc);\n\n  return acc;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Join:%20flatten%20an%20iterable%20of%20iterables][]]\n\n\nfunction join(it1) {\n  return {\n    [Symbol.iterator]: () => {\n      let outerIt = iterableToIterator(it1);\n      let innerIt;\n      let innerDone = true;\n      let allDone = false; // FIXME can one call next repeatedly after past the end?\n\n      return {\n        next: () => {\n          if (allDone) return {\n            done: true\n          }; //            let a: { value: Iterable<T>, done: false } | { done: true };\n          //            let b: { value: T, done: false } | { done: true };\n\n          let a;\n          let b;\n\n          while (true) {\n            if (innerDone == true) {\n              a = outerIt.next();\n              if (a.done) return {\n                done: true\n              };\n              innerIt = iterableToIterator(a.value);\n            }\n\n            b = innerIt.next();\n\n            if (b.done) {\n              innerDone = true;\n              continue;\n            }\n\n            innerDone = false;\n            return {\n              done: false,\n              value: b.value\n            };\n          }\n        },\n        return: v => {\n          if (allDone) return {\n            done: true,\n            value: v\n          };\n          allDone = true;\n\n          if (!innerDone && typeof innerIt.return === 'function') {\n            // FIXME: how to express optional iterator properties in flowtype?\n            innerIt.return(v); // close the currently open inner iterator\n          }\n\n          return {\n            done: true,\n            value: v\n          };\n        },\n        throw: e => {\n          if (allDone) throw e; // FIXME: think how to deal with throw\n        }\n      };\n    }\n  };\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Zip%20and%20zipWith][]]\n\n\nfunction zipWith(fn, it1, it2) {\n  let done = false;\n  return {\n    [Symbol.iterator]: () => {\n      const i1 = it1[Symbol.iterator](),\n            i2 = it2[Symbol.iterator]();\n      return {\n        next: () => {\n          if (done) return {\n            done: true\n          };\n          const a = i1.next(),\n                b = i2.next();\n          done = a.done || b.done;\n          if (!a.done && typeof i1.return === 'function') i1.return();\n          if (!b.done && typeof i2.return === 'function') i2.return();\n          if (done) return {\n            done: true\n          };else {\n            return {\n              done: false,\n              value: fn(a.value, b.value)\n            };\n          }\n        },\n        return: v => {\n          if (typeof i1.return === 'function') i1.return();\n          if (typeof i2.return === 'function') i2.return();\n          done = true;\n          return {\n            done: true,\n            value: v\n          };\n        }\n      };\n    }\n  };\n}\n\nfunction zip(it1, it2) {\n  return zipWith((a, b) => [a, b], it1, it2);\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Bisimilarity][]]\n\n\nfunction bisimilar(it1, it2) {\n  return every2((a, b) => equals(a, b), it1, it2);\n}\n\nfunction bisame(it1, it2) {\n  return every2((a, b) => a === b, it1, it2);\n}\n\nfunction every2(fn, it1, it2) {\n  const i1 = it1[Symbol.iterator](),\n        i2 = it2[Symbol.iterator]();\n\n  while (true) {\n    const a = i1.next(),\n          b = i2.next();\n\n    if (!a.done && !b.done) {\n      if (!fn(a.value, b.value)) return false;else continue;\n    }\n\n    if (a.done && b.done) return true; // in this case i1 and i2 should have released resources\n\n    if (!a.done) {\n      if (typeof i1.return === 'function') i1.return();\n      return false;\n    }\n\n    if (!b.done) {\n      if (typeof i2.return === 'function') i2.return();\n      return false;\n    }\n  }\n\n  return true; // dead code; added to appease flowtype\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*SameElements][]]\n\n\nfunction sameElements(a, b) {\n  let m = new Map();\n\n  for (let k of a) modifyMapValue(m, k, c => c === undefined ? 1 : c + 1);\n\n  for (let k of b) {\n    let c = m.get(k);\n    if (c === 1) m.delete(k);else if (c === undefined) return false; // this closes b\n    else m.set(k, c - 1);\n  }\n\n  return m.size === 0;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*OneToManyMap][]]\n\n\nclass OneToManyMap {\n  constructor() {\n    this._m = new Map();\n  }\n\n  hasKey(k) {\n    return this._m.has(k);\n  }\n\n  keys() {\n    return this._m.keys();\n  }\n\n  values(k) {\n    let s = this._m.get(k);\n\n    if (s !== undefined) return s.values();else return mkEmptyIterable();\n  }\n\n  countKeys() {\n    return this._m.size;\n  }\n\n  count(k) {\n    let s = this._m.get(k);\n\n    return s === undefined ? 0 : s.size;\n  }\n\n  addKey(k) {\n    if (this._m.get(k) === undefined) this._m.set(k, new Set());\n    return this;\n  }\n\n  add(k, v) {\n    let s = this._m.get(k);\n\n    if (s === undefined) {\n      s = new Set();\n\n      this._m.set(k, s);\n    }\n\n    s.add(v);\n    return this;\n  }\n\n  addMany(k, ite) {\n    let s = this._m.get(k);\n\n    if (s === undefined) {\n      s = new Set();\n\n      this._m.set(k, s);\n    } // even with empty iterator, key is always added\n\n\n    for (let v of ite) s.add(v);\n  }\n\n  remove(k, v) {\n    let s = this._m.get(k);\n\n    if (s === undefined) return false;else return s.delete(v);\n  }\n\n  removeKey(k) {\n    this._m.delete(k);\n  }\n\n  clear() {\n    this._m.clear();\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Reference%20Counting][]]\n\n\nexports.OneToManyMap = OneToManyMap;\nlet refCountMap = new WeakMap();\nlet disposerMap = new WeakMap();\nlet uniqueHandlerMap = new WeakMap(); // shall only be called after initRefCounting called\n\nfunction mkRefCounted(o, disposer, uniqueHandler) {\n  _hdconsole.hdconsole.assert(refCount(o) == 0, \"trying to make an object reference counted twice\");\n\n  disposerMap.set(o, disposer);\n  if (uniqueHandler != null) uniqueHandlerMap.set(o, uniqueHandler);\n  refCountMap.set(o, 1);\n  return o;\n}\n\nfunction setUniqueHandler(o, uniqueHandler) {\n  uniqueHandlerMap.set(o, uniqueHandler);\n}\n\n;\n\nfunction retain(o) {\n  let cnt = refCountMap.get(o);\n\n  _hdconsole.hdconsole.assert(cnt != null, \"trying to retain a non-refcounted object\");\n\n  refCountMap.set(o, cnt + 1);\n  return o;\n}\n\nfunction release(o) {\n  let cnt = refCountMap.get(o);\n\n  _hdconsole.hdconsole.assert(cnt != null && cnt > 0, \"trying to release an already released object\");\n\n  --cnt;\n  refCountMap.set(o, cnt);\n  if (cnt > 1) return cnt;\n\n  if (cnt === 1) {\n    let uniqueHandler = uniqueHandlerMap.get(o);\n    if (uniqueHandler != null) uniqueHandler(o);\n  } else {\n    // cnt === 0\n    let disposer = disposerMap.get(o);\n    if (disposer != null) disposer(o);\n  }\n\n  return cnt;\n}\n\nfunction refCount(o) {\n  let cnt = refCountMap.get(o);\n  return cnt === undefined ? 0 : cnt;\n}\n\nfunction isUnique(o) {\n  return refCount(o) === 1;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*List%20of%20reference%20counted%20objects][]]\n\n\nclass RefList {\n  constructor() {\n    this._head = null;\n  }\n\n  front() {\n    if (this._head != null) return this._head.data;\n  }\n\n  pushFront(t) {\n    this._head = new RefListNode(this._head, t);\n    return this._head;\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*List%20of%20reference%20counted%20objects][]]\n\n\nexports.RefList = RefList;\n\nclass RefListNode {\n  constructor(n, d) {\n    console.assert(refCount(d) > 0);\n    this.next = n;\n    this.data = d;\n  }\n\n  releaseTail() {\n    let n = this.next;\n\n    while (n != null) {\n      release(n.data);\n      n = n.next;\n    }\n\n    this.next = null;\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Linked%20List][]]\n\n\nexports.RefListNode = RefListNode;\n\nclass ListNode {\n  constructor(p, n, d) {\n    this.prev = p;\n    this.next = n;\n    this.data = d;\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Linked%20List][]]\n\n\nexports.ListNode = ListNode;\n\nclass LinkedList {\n  constructor() {\n    this._head = null;\n    this._tail = null;\n    this._size = 0;\n  }\n\n  insertNode(pos, n) {\n    if (pos == null) {\n      n.prev = this._tail;\n      n.next = null;\n      this._tail = n;\n    } else {\n      n.prev = pos.prev;\n      n.next = pos;\n      pos.prev = n;\n    }\n\n    if (n.prev == null) this._head = n;else n.prev.next = n;\n    this._size++;\n    return n;\n  }\n\n  insert(pos, v) {\n    return this.insertNode(pos, new ListNode(null, null, v));\n  }\n\n  pushFront(v) {\n    return this.insert(this._head, v);\n  }\n\n  pushNodeFront(n) {\n    return this.insertNode(this._head, n);\n  }\n\n  pushBack(v) {\n    return this.insert(null, v);\n  }\n\n  pushNodeBack(n) {\n    return this.insertNode(null, n);\n  }\n\n  removeNode(pos) {\n    if (pos.next == null) this._tail = pos.prev;else pos.next.prev = pos.prev;\n    if (pos.prev == null) this._head = pos.next;else pos.prev.next = pos.next;\n    this._size--;\n    return pos;\n  }\n\n  remove(pos) {\n    return this.removeNode(pos).data;\n  }\n\n  popFront() {\n    return this._head == null ? null : this.remove(this._head);\n  }\n\n  popBack() {\n    return this._tail == null ? null : this.remove(this._tail);\n  }\n  /*:: @@iterator(): Iterator<T> { return ({}: any); } */\n  // $FlowFixMe: computed property\n\n\n  [Symbol.iterator]() {\n    let curr = this._head;\n    return {\n      next: () => {\n        if (curr == null) return {\n          done: true\n        };else {\n          let r = {\n            value: curr.data,\n            done: false\n          };\n          curr = curr.next;\n          return r;\n        }\n      }\n    };\n  }\n\n  reverseIterator() {\n    let curr = this._tail;\n    return {\n      next: () => {\n        if (curr == null) return {\n          done: true\n        };else {\n          let r = {\n            value: curr.data,\n            done: false\n          };\n          curr = curr.prev;\n          return r;\n        }\n      }\n    };\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Linked%20List%20with%20random%20access][]]\n\n\nexports.LinkedList = LinkedList;\n\nclass PriorityList {\n  size() {\n    return this._list._size;\n  }\n\n  constructor() {\n    this._nodeMap = new Map();\n    this._list = new LinkedList();\n    this._highestPriority = -1;\n    this._lowestPriority = 0;\n  } // FIXME: if insert in the middle, may have to assign priorities down (or up) to list\n  // For now this is not implemented, as it is unsure whether it will be needed or not\n  // insertBefore(t: ?T, u: T) {\n  //  let n = t != null ? this._nodeMap.get(t) : null;\n  //  this._list.insert(n, u); // inserts as last if t null or not found\n  // }\n  // Precondition: t is in the priority list\n\n\n  _access(t) {\n    let n = this._nodeMap.get(t);\n\n    if (n == null) console.log(t.name);\n    if (n == null) console.log(this.size());\n\n    _hdconsole.hdconsole.assert(n != null, \"element not found in priority list\");\n\n    if (n == null) throw \"Should not happen, element not found in priority list\"; // this is to appease flow\n\n    return n;\n  }\n\n  remove(t) {\n    let n = this._nodeMap.get(t);\n\n    if (n != null) {\n      // only remove if not already removed\n      this._nodeMap.delete(t);\n\n      this._list.remove(n);\n    }\n  }\n\n  promote(t) {\n    let node = this._access(t);\n\n    node.data.priority = ++this._highestPriority;\n\n    this._list.pushNodeFront(this._list.removeNode(node));\n  }\n\n  demote(t) {\n    let node = this._access(t);\n\n    node.data.priority = --this._lowestPriority;\n\n    this._list.pushNodeBack(this._list.removeNode(node));\n  }\n\n  get highestPriority() {\n    return this._highestPriority;\n  }\n\n  get lowestPriority() {\n    return this._lowestPriority;\n  }\n\n  priority(t) {\n    return this._access(t).data.priority;\n  }\n\n  pushBack(t) {\n    this._nodeMap.set(t, this._list.pushBack({\n      data: t,\n      priority: --this._lowestPriority\n    }));\n  }\n\n  pushFront(t) {\n    this._nodeMap.set(t, this._list.pushFront({\n      data: t,\n      priority: ++this._highestPriority\n    }));\n  } // an iterable that iterates over just the T values, ignores priority value\n\n\n  entries() {\n    return map(pd => pd.data, this);\n  }\n  /*:: @@iterator(): Iterator<PriData<T>> { return ({}: any); } */\n  // $FlowFixMe: computed property\n\n\n  [Symbol.iterator]() {\n    return this._list[Symbol.iterator]();\n  }\n\n  hasHigherPriority(a, b) {\n    return this._access(a).data.priority > this._access(b).data.priority;\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::#sec:observable-reference][]]\n\n\nexports.PriorityList = PriorityList;\n\nclass ObservableReference {\n  // holds observers \n  // link to another reference\n  constructor(value = null) {\n    this._value = value;\n    this._subject = new Obs.Subject(o => {\n      o.next(this._value);\n    });\n    this._subscription = null;\n  }\n\n  subscribe(s) {\n    return this._subject.subscribe(s);\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(v) {\n    if (this._subscription != null) {\n      this._subscription.unsubscribe();\n\n      this._subscription = null;\n    }\n\n    this._setValue(v);\n  }\n\n  _setValue(v) {\n    if (this._value !== null) this._subject.sendNext(null);\n    this._value = v;\n    if (v !== null) this._subject.sendNext(v);\n  }\n\n  link(target) {\n    this.value = null; // unsubscribes, if already linked\n\n    this._subscription = target.subscribe(v => {\n      this._setValue(v);\n    });\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Flowtype][]]\n\n\nexports.ObservableReference = ObservableReference;\n\nfunction throw_on_null(t) {\n  if (t == null) throw \"Expected non-null\";\n  return t;\n}\n\nfunction nonnull_cast(t) {\n  return t;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Heap%20Data%20Structure][]]\n\n\nclass BinaryHeap {\n  constructor(cmp) {\n    this._cmp = cmp;\n    this._data = [null]; // empty unused element at 0 allows simpler index math\n  }\n\n  size() {\n    return this._data.length - 1;\n  }\n\n  empty() {\n    return this.size() === 0;\n  }\n\n  _swap(i, j) {\n    let tmp = this._data[i];\n    this._data[i] = this._data[j];\n    this._data[j] = tmp;\n  }\n\n  _percolateUp(i) {\n    while (i >= 2) {\n      let parent = Math.floor(i / 2);\n\n      if (this._cmp(this._data[i], this._data[parent])) {\n        this._swap(i, parent);\n\n        i = parent;\n      } else break;\n    }\n  }\n\n  push(t) {\n    this._data.push(t);\n\n    this._percolateUp(this.size());\n  }\n\n  _percolateDown(i) {\n    while (2 * i <= this.size()) {\n      let smallerChild = this._minOfSiblings(2 * i);\n\n      if (!this._cmp(this._data[i], this._data[smallerChild])) {\n        this._swap(i, smallerChild);\n\n        i = smallerChild;\n      } else break;\n    }\n  }\n\n  _minOfSiblings(i) {\n    if (i >= this.size() || this._cmp(this._data[i], this._data[i + 1])) return i;else return i + 1;\n  }\n\n  pop() {\n    let ret = this._data[1];\n\n    let last = this._data.pop();\n\n    if (this.size() > 0) {\n      this._data[1] = last;\n\n      this._percolateDown(1);\n    }\n\n    return ret;\n  }\n\n} // ends here\n// Tangle:1 ends here\n\n\nexports.BinaryHeap = BinaryHeap;\n\n//# sourceURL=webpack://hd/./lib/utilities.js?");

/***/ }),

/***/ "./src/computation-graph.js":
/*!**********************************!*\
  !*** ./src/computation-graph.js ***!
  \**********************************/
/*! exports provided: VariableActivation, MethodActivation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VariableActivation\", function() { return VariableActivation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MethodActivation\", function() { return MethodActivation; });\n/* harmony import */ var _src_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/utilities */ \"./src/utilities.js\");\n/* harmony import */ var _src_constraint_system__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/constraint-system */ \"./src/constraint-system.js\");\n/* harmony import */ var _src_hdconsole__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/hdconsole */ \"./src/hdconsole.js\");\n// [[file:~/git/hd4/org/computation-graph.org::*Tangle][Tangle:2]]\n\n\n\n\nclass Deferred {\n  constructor() {\n    this._promise = new Promise((r, j) => {\n      this.resolve = v => {\n        r(v);\n      };\n\n      this.reject = e => {\n        j(e);\n      };\n    });\n  }\n\n  get promise() {\n    return this._promise;\n  }\n\n}\n\nclass TrackingPromise {\n  constructor(p, tracker) {\n    this._promise = p;\n    this._fulfillTracker = tracker;\n  }\n\n  then(onFulfilled, onRejected) {\n    if (onFulfilled != null) this._fulfillTracker();\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    return this._promise.catch(onRejected);\n  }\n\n  finally(onFinally) {\n    return this._promise.finally(onFinally);\n  }\n\n}\n\nconst abandoned = {};\nclass VariableActivation {\n  constructor(v) {\n    this._pending = false;\n    this._variable = v;\n    this._deferred = new Deferred();\n    this._outMethods = new Set();\n    this._inMethod = null;\n    _src_utilities__WEBPACK_IMPORTED_MODULE_0__[\"mkRefCounted\"](this, t => {\n      t.reject(VariableActivation.abandoned);\n      t._inMethod = null;\n      return;\n    });\n  }\n\n  get name() {\n    return this._variable.name;\n  }\n\n  get inMethod() {\n    return this._inMethod;\n  }\n\n  get outMethods() {\n    return this._outMethods;\n  }\n\n  outMethodsSize() {\n    return this._outMethods.size;\n  }\n\n  addOutMethod(m) {\n    this._outMethods.add(m);\n  }\n\n  setInMethod(m) {\n    this._inMethod = m;\n  }\n\n  resolve(v) {\n    this._pending = false;\n    return this._deferred.resolve(v);\n  }\n\n  reject(e) {\n    this._pending = false;\n    return this._deferred.reject(e);\n  }\n\n  get promise() {\n    return this._deferred.promise;\n  }\n\n}\nVariableActivation.abandoned = {};\nclass MethodActivation {\n  constructor(f, promiseMask) {\n    this._f = f;\n    this._mask = promiseMask;\n  }\n\n  get ins() {\n    return this._ins;\n  }\n\n  get outs() {\n    return this._outs;\n  }\n\n  insSize() {\n    return this._ins.length;\n  }\n\n  outsSize() {\n    return this._outs.length;\n  }\n\n  async execute(ins, outs) {\n    this._ins = ins;\n    this._outs = outs;\n    outs.forEach(o => o.setInMethod(this)); // retain all inputs\n\n    ins.forEach(i => _src_utilities__WEBPACK_IMPORTED_MODULE_0__[\"retain\"](i)); // once _all_ output variable activations have been settled\n    // (either by this method or by becoming abandoned), this method\n    // activation has no use anymore; in particular it does not need\n    // its input activations anymore, and it will release them.  We\n    // use Promise.all to detect when all outputs have been settled\n    // or rejected, but since Promise.all rejects immediately if any\n    // of the promises it waits rejects, we do not wait for the output\n    // promises directly, but rather for another set of promises\n    // (oproms) that wrap the output promises and resolve regardless\n    // whether the corresponding outputs reject or resolve.\n\n    let oproms = outs.map(o => o.promise.then(v => null, e => null));\n    Promise.all(oproms).then(() => {\n      ins.forEach(i => {\n        _src_utilities__WEBPACK_IMPORTED_MODULE_0__[\"release\"](i);\n      });\n    }); // FIXME: this can be replaced with Promise.allSettled(), once\n    // it becomes supported\n\n    let nonpromiseIns = ins.filter((e, i) => (this._mask[i] & _src_constraint_system__WEBPACK_IMPORTED_MODULE_1__[\"maskPromise\"]) === 0); // these are regular in-parameters that are awaited before passing into method's f\n\n    let modifiedIns = ins.filter((e, i) => (this._mask[i] & _src_constraint_system__WEBPACK_IMPORTED_MODULE_1__[\"maskUpdate\"]) !== 0); // these are the inputs that are also outputs, and where there is aliasing between\n    // the input and the output. Methods that perform this kind of modification can only \n    // be executed when the inputs have reference count 1 (then all the other methods that\n    // use those inputs have already finished (there can be at most one method that performs\n    // such a modifying write)\n\n    let mCount = modifiedIns.length;\n\n    if (mCount > 0) {\n      let def = new Deferred();\n      let arr = [];\n\n      for (let i = 0; i < modifiedIns.length; ++i) {\n        arr.push(modifiedIns[i].name);\n        _src_utilities__WEBPACK_IMPORTED_MODULE_0__[\"setUniqueHandler\"](modifiedIns[i], v => {\n          if (--mCount === 0) def.resolve(null);\n        });\n      }\n\n      await def.promise; // now all possibly modifying variables have only one reference\n    }\n\n    let inValues;\n\n    try {\n      // await for all non-promise inputs\n      inValues = await Promise.all(nonpromiseIns.map(v => v.promise));\n    } catch (e) {\n      // if any non-promise input rejects, the wrapped f cannot be called, so\n      // all outputs can be rejected\n      outs.forEach(o => o.reject(\"a method's input was rejected\"));\n      return;\n    } // construct the wrapped f's input argument from promise inputs\n    // and the resolved values of non-promise inputs\n\n\n    let inArgs = [],\n        vind = 0;\n\n    for (let i = 0; i < ins.length; ++i) {\n      if ((this._mask[i] & _src_constraint_system__WEBPACK_IMPORTED_MODULE_1__[\"maskPromise\"]) !== 0) {\n        inArgs[i] = new TrackingPromise(ins[i].promise, () => ins[i].addOutMethod(this));\n      } else {\n        ins[i].addOutMethod(this);\n        inArgs[i] = inValues[vind++];\n      }\n    }\n\n    let r;\n\n    try {\n      r = await this._f(...inArgs); // in case of one return, result can be\n      // a promise, we await for it here to\n      // avoid unhandled rejection. (This also\n      // allows a method that returns a\n      // promise that resolves to an array)\n    } catch (e) {\n      // this error is from f itself; therefore we reject all outputs\n      // with the reason e\n      outs.forEach(o => o.reject(e));\n      return;\n    } // if method has more than one output, f should return an array\n\n\n    if (outs.length > 1) {\n      console.assert(Array.isArray(r) && outs.length == r.length, `Method result shoud be an array of ${outs.length} elements`);\n\n      for (let i = 0; i < r.length; ++i) outs[i].resolve(r[i]); // r[i] can be a promise or a value\n\n    } else {\n      // only one output; result of f is not expected to be wrapped in a singleton array\n      outs[0].resolve(r);\n    }\n  }\n\n}\n\nclass EvaluationGraph {\n  adjacentOutVertices(v) {\n    if (v instanceof VariableActivation) return v.outMethods;else return v.outs;\n  }\n\n  outDegree(v) {\n    if (v instanceof VariableActivation) return v.outMethodsSize();else return v.outsSize();\n  }\n\n  adjacentInVertices(v) {\n    if (v instanceof VariableActivation) return v.inMethod != null ? [v.inMethod] : [];else return v.ins;\n  }\n\n  inDegree(v) {\n    if (v instanceof VariableActivation) return v.inMethod != null ? 1 : 0;else return v.insSize();\n  }\n\n} // Tangle:2 ends here\n\n//# sourceURL=webpack://hd/./src/computation-graph.js?");

/***/ }),

/***/ "./src/constraint-system.js":
/*!**********************************!*\
  !*** ./src/constraint-system.js ***!
  \**********************************/
/*! exports provided: maskNone, maskPromise, maskUpdate, maskPromiseUpdate, Method, ConstraintSpec, VariableReference, mkVariable, Variable, Component, freshComponentName, isOwnerOf, Constraint, ConstraintSystem, DownstreamSolutionGraph, UpstreamSolutionGraph, SimplePlanner, enforceStayMethod, isStay */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"maskNone\", function() { return maskNone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"maskPromise\", function() { return maskPromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"maskUpdate\", function() { return maskUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"maskPromiseUpdate\", function() { return maskPromiseUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Method\", function() { return Method; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConstraintSpec\", function() { return ConstraintSpec; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VariableReference\", function() { return VariableReference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkVariable\", function() { return mkVariable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Variable\", function() { return Variable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"freshComponentName\", function() { return freshComponentName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isOwnerOf\", function() { return isOwnerOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Constraint\", function() { return Constraint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConstraintSystem\", function() { return ConstraintSystem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DownstreamSolutionGraph\", function() { return DownstreamSolutionGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UpstreamSolutionGraph\", function() { return UpstreamSolutionGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SimplePlanner\", function() { return SimplePlanner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enforceStayMethod\", function() { return enforceStayMethod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isStay\", function() { return isStay; });\n/* harmony import */ var _graph_algorithms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-algorithms */ \"./src/graph-algorithms.js\");\n/* harmony import */ var _computation_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./computation-graph */ \"./src/computation-graph.js\");\n/* harmony import */ var _hdconsole__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hdconsole */ \"./src/hdconsole.js\");\n/* harmony import */ var _observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observable */ \"./src/observable.js\");\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utilities */ \"./src/utilities.js\");\n\n\n\n\n\nconst maskNone = 0;\nconst maskPromise = 1;\nconst maskUpdate = 2;\nconst maskPromiseUpdate = maskPromise | maskUpdate;\nclass Method {\n  constructor(nvars, ins, outs, promiseMask, code, name) {\n    this._ins = new Set(ins);\n    this._outs = new Set(outs); // compute _nonOuts\n\n    let indices = Array.from(Array(nvars).keys()); // [0, 1, ..., nvars-1]\n\n    this._outs.forEach(i => indices[i] = null); // mark with null the indices that are outputs\n\n\n    this._nonOuts = new Set();\n\n    for (let e of indices) {\n      if (e != null) this._nonOuts.add(e);\n    }\n\n    this._promiseMask = Array.from(promiseMask);\n    _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(this._ins.size == this._promiseMask.length, \"Number of input arguments and length of promise mask must be the same\");\n    this.code = code;\n    if (name != null) this._name = name;\n  }\n\n  get name() {\n    return this._name == null ? \"\" : this._name;\n  }\n\n  get nvars() {\n    return this._outs.size + this._nonOuts.size;\n  }\n\n  validIndex(i) {\n    return i >= 0 && i < this.nvars;\n  }\n\n  ins() {\n    return this._ins;\n  }\n\n  outs() {\n    return this._outs;\n  }\n\n  nonOuts() {\n    return this._nonOuts;\n  }\n\n  vIns(vs) {\n    return _utilities__WEBPACK_IMPORTED_MODULE_4__[\"map\"](i => vs[i], this._ins);\n  }\n\n  vOuts(vs) {\n    return _utilities__WEBPACK_IMPORTED_MODULE_4__[\"map\"](i => vs[i], this._outs);\n  }\n\n  vNonOuts(vs) {\n    return _utilities__WEBPACK_IMPORTED_MODULE_4__[\"map\"](i => vs[i], this._nonOuts);\n  }\n\n  nIns() {\n    return this._ins.size;\n  }\n\n  nOuts() {\n    return this._outs.size;\n  }\n\n  nNonOuts() {\n    return this._nonOuts.size;\n  }\n\n  isIn(i) {\n    return this._ins.has(i);\n  }\n\n  isOut(i) {\n    return this._outs.has(i);\n  }\n\n  isNonOut(i) {\n    return this._nonOuts.has(i);\n  }\n\n  prettyPrint(vrefs) {\n    let s = this.name + \"(\";\n\n    for (const i of this._nonOuts) s += vrefs[i].name + \" \";\n\n    s += \"->\";\n\n    for (const i of this._outs) s += \" \" + vrefs[i].name;\n\n    s += \");\";\n    return s;\n  }\n\n}\nclass ConstraintSpec {\n  constructor(methods) {\n    this._methods = new Set(methods);\n    _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(this._methods.size > 0, \"Constraint specification must have at least one method.\");\n    const nvars = _utilities__WEBPACK_IMPORTED_MODULE_4__[\"first\"](this._methods).nvars;\n    this._nvars = nvars;\n    this._v2ins = [];\n\n    for (let i = 0; i < nvars; ++i) this._v2ins.push([]);\n\n    for (let m of this._methods) {\n      _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(m.nvars === nvars, `All methods in constraint specification must have the same number of variables`);\n\n      for (let i of m.outs()) {\n        this._v2ins[i].push(m);\n      }\n    }\n  }\n\n  get nvars() {\n    return this._nvars;\n  }\n\n  ins(vIndex) {\n    return this._v2ins[vIndex];\n  }\n\n  insSize(vIndex) {\n    return this._v2ins[vIndex].length;\n  }\n\n  methods() {\n    return this._methods;\n  }\n\n  hasMethod(m) {\n    return this._methods.has(m);\n  }\n\n  prettyPrint(prefix, vrefs) {\n    let s = \"\";\n\n    for (let m of this._methods) {\n      s += prefix + m.prettyPrint(vrefs) + \"\\n\";\n    }\n\n    return s;\n  }\n\n}\nclass VariableReference extends _utilities__WEBPACK_IMPORTED_MODULE_4__[\"ObservableReference\"] {\n  constructor(owner) {\n    super();\n    this._owner = owner;\n  }\n\n  get system() {\n    return this._owner.system;\n  }\n\n  get name() {\n    return this._owner.variableReferenceName(this);\n  }\n\n  isOwningReference() {\n    return this.value == null ? false : this.value._owner === this;\n  }\n\n  prettyPrint() {\n    let s = this.name;\n    if (this.value != null) s += \":\" + this.value._index;\n    return s;\n  }\n\n}\nfunction mkVariable(owner, v) {\n  let r = new VariableReference(owner);\n  r.value = new Variable(r, v);\n  return r;\n}\n\nlet freshIndex = (() => {\n  let ind = 0;\n  return () => ++ind;\n})();\n\nclass Variable {\n  // for debugging purposes\n  // holds observers\n  get value() {\n    return this._inError ? undefined : this._value;\n  }\n\n  get error() {\n    return this._inError ? this._error : undefined;\n  }\n\n  get stale() {\n    return !this._pending && this._inError;\n  }\n\n  get pending() {\n    return this._pending;\n  }\n\n  constructor(owner, v = undefined) {\n    this._index = freshIndex();\n    this._owner = owner;\n    this._value = undefined;\n    this._error = undefined;\n    this._inError = false;\n    this._pending = true;\n    this._subject = new _observable__WEBPACK_IMPORTED_MODULE_3__[\"Subject\"](o => {\n      let evt = {\n        value: this._value,\n        pending: this._pending,\n        inError: this._inError\n      };\n      if (this._inError) evt.error = this._error;\n      o.next(evt);\n    });\n    this.pushNewActivation();\n    if (v !== undefined) this._activation.resolve(v);\n  }\n\n  subscribe(o) {\n    return this._subject.subscribe(o);\n  }\n\n  subscribeValue(o) {\n    return this._subject.filter(e => e.hasOwnProperty('value')).map(e => e.value).subscribe(o);\n  }\n\n  subscribePending(o) {\n    return this._subject.filter(e => e.hasOwnProperty('pending')).map(e => e.pending).subscribe(o);\n  }\n\n  subscribeError(o) {\n    return this._subject.filter(e => e.hasOwnProperty('inError') || e.hasOwnProperty('error')).map(e => {\n      let r = {};\n      if (e.hasOwnProperty('error')) r.error = e.error;\n      if (e.hasOwnProperty('inError')) r.inError = e.inError;\n      return r;\n    }).subscribe(o);\n  }\n\n  pushNewActivation() {\n    let r = new _computation_graph__WEBPACK_IMPORTED_MODULE_1__[\"VariableActivation\"](this);\n    this._activation = r;\n\n    if (this._pending === false) {\n      this._pending = true;\n\n      this._subject.sendNext({\n        pending: true\n      });\n    }\n\n    r.promise.then(val => {\n      if (r === this._activation) {\n        // is the activation still the newest\n        this._value = val;\n        let evt = {\n          value: val\n        };\n\n        if (this._inError) {\n          this._inError = false;\n          evt.inError = false;\n        }\n\n        this._pending = false;\n        evt.pending = false;\n\n        this._subject.sendNext(evt);\n      }\n    }, e => {\n      if (r === this._activation) {\n        this._error = e;\n        let evt = {\n          error: e\n        };\n\n        if (!this._inError) {\n          this._inError = true;\n          evt.inError = true;\n        }\n\n        this._pending = false;\n        evt.pending = false;\n\n        this._subject.sendNext(evt);\n      }\n    });\n    return r;\n  }\n\n  get currentPromise() {\n    return this._activation.promise;\n  }\n\n  get owner() {\n    return this._owner;\n  }\n\n  get system() {\n    return this._owner.system;\n  }\n\n  get name() {\n    if (this._owner == null) return \"<unnamed>\";else return this._owner.name;\n  }\n\n  set(v) {\n    this.assign(v);\n    let s = this.system;\n    if (s != null) s.updateDirty();\n    return this;\n  }\n\n  fail(e) {\n    this._assign().reject(e);\n\n    let s = this.system;\n    if (s != null) s.updateDirty();\n    return this;\n  }\n\n  assign(v) {\n    this._assign().resolve(v);\n  }\n\n  _assign() {\n    let prevActivation = this._activation;\n    this.pushNewActivation();\n    let s = this.system;\n\n    if (s != null) {\n      s.promoteVariable(this);\n      let sc = s.getSourceConstraint(this);\n      if (sc != null) s.setDirty(sc);\n      s.setDirty(s.getStay(this));\n    }\n\n    _utilities__WEBPACK_IMPORTED_MODULE_4__[\"release\"](prevActivation);\n    return this._activation;\n  }\n\n  touch() {\n    let s = this.system;\n    if (s != null) s.promoteVariable(this);\n    return this;\n  }\n\n  _touchPlanSolve() {\n    this.touch();\n    let s = this.system;\n    let prevActivation = this._activation;\n    this.pushNewActivation();\n\n    if (s == null) {\n      _utilities__WEBPACK_IMPORTED_MODULE_4__[\"release\"](prevActivation);\n      return this._activation;\n    }\n\n    let pushedActivation = this._activation;\n    let sc = s.getSourceConstraint(this);\n    s.setDirty(sc != null ? sc : s.getStay(this));\n    s.updateDirty(); // solving pushes new activations to variables, also possibly to this._activation.\n    // This happens if 'this' cannot stay in the current plan.\n\n    _utilities__WEBPACK_IMPORTED_MODULE_4__[\"release\"](prevActivation); // return the activation that should be resolved or rejected\n\n    return pushedActivation;\n  }\n\n}\nclass Component {\n  // used for generating fresh constraint names\n  constructor(name) {\n    this._owner = null;\n    this._system = null;\n    this._name = name;\n    this._vars = new Set();\n    this._varRefs = new Map();\n    this._varRefNames = new Map();\n    this._constraints = new Map();\n    this._constraintNames = new Map();\n    this._nextFreshCIndex = 0;\n    this._components = new Map();\n  }\n\n  clone(name = freshComponentName()) {\n    let that = new Component(name);\n    let o2n = new Map(); // old2new \n    // clone variable references\n\n    for (let [n, v] of this._varRefs) {\n      if (v.isOwningReference()) {\n        o2n.set(v, that.emplaceVariable(n));\n      } else o2n.set(v, that.emplaceVariableReference(n));\n    } // clone constraints\n\n\n    for (let [n, c] of this._constraints) {\n      let nrefs = c._varRefs.map(vr => o2n.get(vr));\n\n      if (!isStay(c)) that.emplaceConstraint(n, c._cspec, nrefs, c._optional);\n    } // clone nested components\n\n\n    for (let [n, cmp] of this._components) that.addComponent(cmp.clone(n));\n\n    return that;\n  }\n\n  get system() {\n    return this._system;\n  }\n\n  connectSystem(system) {\n    if (this._owner != null) {\n      _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].error(`Tried to connect the nested component ${this._name}`);\n      return false;\n    }\n\n    if (this._system === system) {\n      _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].warn(`Same system connected twice to component ${this._name}`);\n      return false;\n    }\n\n    if (this._system != null) {\n      _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].error(`Trying to connect an already connected component ${this._name} to a another system`);\n      return false;\n    }\n\n    this._connectSystem(system);\n\n    return true;\n  }\n\n  _connectSystem(system) {\n    this._system = system; // must set system already here\n    // so that connect notifications \n    // compare systems correctly FIXME: think abou this\n\n    for (let c of this._components.values()) c._connectSystem(system);\n\n    for (let c of this._constraints.values()) if (c._danglingCount === 0) system.addConstraint(c);\n  }\n\n  disconnectSystem() {\n    if (this._system == null) {\n      _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].error(`Tried to disconnect a component ${this._name} that is already disconnected`);\n      return false;\n    }\n\n    if (this._owner != null) {\n      _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].error(`Tried to disconnect a subcomponent ${this._name} when owner is still connected`);\n      return false;\n    }\n\n    this._disconnectSystem();\n\n    return true;\n  }\n\n  _disconnectSystem() {\n    for (let c of this._components.values()) c._disconnectSystem();\n\n    for (let c of this._constraints.values()) this._system.removeConstraint(c); // cast OK since we know system is connected\n\n\n    this._system = null;\n  }\n\n  addComponent(c) {\n    if (c._owner != null) {\n      _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].error(`Tried to add component ${c._name} that already has an owner to component ${this._name}`);\n      return;\n    }\n\n    if (c._system != null) {\n      _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].error(`Tried to add to component ${this._name} the component ${c._name} that is connected to a system`);\n      return;\n    }\n\n    if (this._components.has(c._name)) {\n      _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].error(`Tried to add the component whose name ${c._name} already exists`);\n      return;\n    }\n\n    c._owner = this;\n\n    this._components.set(c._name, c);\n\n    if (this._system != null) c.connectSystem(this._system);\n  }\n\n  emplaceVariable(n, v) {\n    _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(!this._varRefs.has(n), `Trying to add variable ${n} twice to component ${this._name}`);\n    let vr = mkVariable(this, v);\n\n    this._varRefs.set(n, vr);\n\n    this._varRefNames.set(vr, n);\n\n    this._vars.add(vr.value); // cast ok, vr is an owning reference\n\n\n    let name = \"__stay__\" + n;\n    let c = new Constraint(this, stayConstraintSpec, [vr], true);\n\n    this._constraints.set(name, c);\n\n    this._constraintNames.set(c, name);\n\n    return vr;\n  }\n\n  emplaceVariableReference(n) {\n    _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(!this._varRefs.has(n), `Trying to add variable reference ${n} twice to component ${this._name}`);\n    let vr = new VariableReference(this);\n\n    this._varRefs.set(n, vr);\n\n    this._varRefNames.set(vr, n);\n\n    return vr;\n  }\n\n  emplaceConstraint(n, cspec, vrefs, optional = false) {\n    let c = new Constraint(this, cspec, vrefs, optional);\n    if (n == null) n = this._nextFreshConstraintName();\n    if (this._constraints.has(n)) throw `Constraint ${n} already exists in component ${this._name}`;\n\n    this._constraints.set(n, c);\n\n    this._constraintNames.set(c, n);\n\n    return c;\n  }\n\n  _nextFreshConstraintName() {\n    return \"c#\" + this._nextFreshCIndex++;\n  }\n\n  variableReferenceName(r) {\n    let s = this._varRefNames.get(r);\n\n    return s == null ? \"<unnamed>\" : s;\n  }\n\n  constraintName(c) {\n    return this._constraintNames.get(c);\n  }\n\n  getVariableReference(n) {\n    let r = this._varRefs.get(n);\n\n    if (r != null) return r;\n    if (this._owner == null) return undefined;\n    return this._owner.getVariableReference(n);\n  }\n\n  get vs() {\n    return new Proxy(this, {\n      get: function (target, property) {\n        return target._varRefs.get(property);\n      },\n      set: function (target, property, value, receiver) {\n        let r = target._varRefs.get(property);\n\n        if (r == null) {\n          _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].warn(`Linking an unknown variable ${property}`);\n          return false; // this causes a TypeError in strict mode\n        } else {\n          r.link(value);\n          return true;\n        }\n      }\n    });\n  }\n\n  get cs() {\n    return new Proxy(this, {\n      get: function (target, property) {\n        return target._constraints.get(property);\n      }\n    });\n  }\n\n  get components() {\n    return new Proxy(this, {\n      get: function (target, property) {\n        return target._components.get(property);\n      }\n    });\n  }\n\n}\n\nfunction freshNameGenerator(prefix) {\n  let n = 0;\n  return () => prefix + n++;\n}\n\nconst freshComponentName = freshNameGenerator(\"comp#\");\n\nfunction isOwnerOf(c1, c2) {\n  while (c1 !== c2) {\n    if (c2._owner == null) return false;else c2 = c2._owner;\n  }\n\n  return true;\n} // FIXME: these are hacks because of trouble with instanceof and babel\n\nfunction isConstraint(c) {\n  return c.hasOwnProperty(\"_cspec\");\n}\n\nfunction isVariable(v) {\n  return v.hasOwnProperty(\"_activation\");\n}\n\nfunction isMethod(v) {\n  return v.hasOwnProperty(\"_promiseMask\");\n}\n\nclass Constraint {\n  // used in pruning\n  // used in pruning\n  // used in pruning\n  prettyPrint() {\n    let s = \"constraint \" + this.name + \" {\\n\";\n    s += \"  \";\n\n    for (let vr of this._varRefs) s += vr.prettyPrint() + \"; \";\n\n    s += \"\\n\";\n    s += this._cspec.prettyPrint(\"  \", this._varRefs);\n    s += \"}\\n\";\n    return s;\n  }\n\n  substitute(vrs) {\n    return new Constraint(this._owner, this._cspec, vrs, this._optional);\n  }\n\n  constructor(owner, cspec, vrefs, optional = false) {\n    this._owner = owner;\n    this._cspec = cspec;\n    this._varRefs = [];\n    this._vars = Array(cspec.nvars).fill(null);\n    this._used = Array(cspec.nvars).fill(true); // FIXME: this is probably not used anymore\n\n    this._danglingCount = cspec.nvars;\n    this._optional = optional; // _vars is only used when all refs are resolved\n\n    this._indices = new Map();\n    let i = 0;\n\n    for (let r of vrefs) {\n      _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(isOwnerOf(r._owner, this._owner), `Constructing constraint ${this.name} with a foreign variable reference`);\n      this._varRefs[i] = r;\n      {\n        let index = i; // for correct scoping\n\n        r.subscribe(v => {\n          if (v !== null) {\n            // connect\n            if (this._vars[index] !== null) console.log(\"NOTNULL\", this._vars[index]); // FIXME: is this necessary still?\n\n            this._vars[index] = v;\n\n            this._indices.set(v, index);\n\n            if (--this._danglingCount == 0) {\n              let s = this.system;\n              if (s != null) s.addConstraint(this);\n            }\n          } else {\n            // disconnect\n            if (this._vars[index] === null) return; // already disconnected\n\n            if (this._danglingCount++ == 0) {\n              let s = this.system;\n              if (s != null) s.removeConstraint(this);\n            }\n\n            this._indices.delete(this._vars[index]);\n\n            this._vars[index] = null;\n          }\n        });\n      }\n      ++i;\n    }\n\n    this._initPruningData();\n\n    this.clearSelectedMethod();\n  }\n\n  equals(c) {\n    return this === c;\n  }\n\n  get name() {\n    return this._owner == null ? \"<unnamed>\" : this._owner.constraintName(this);\n  }\n\n  get nvars() {\n    return this._cspec.nvars;\n  }\n\n  get system() {\n    return this._owner.system;\n  }\n\n  i2v(i) {\n    return this._vars[i];\n  }\n\n  v2i(v) {\n    _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(this._indices.has(v), \"unknown variable in Constraint.v2i: \" + v.name);\n    return this._indices.get(v);\n  }\n\n  variables() {\n    return this._vars;\n  }\n\n  outs(m) {\n    return m.vOuts(this._vars);\n  }\n\n  ins(m) {\n    return m.vIns(this._vars);\n  }\n\n  nonOuts(m) {\n    return m.vNonOuts(this._vars);\n  }\n\n  methods() {\n    return this._cspec.methods();\n  }\n\n  hasMethod(m) {\n    return this._cspec.hasMethod(m);\n  }\n\n  viableMethods() {\n    return this._viableMethods;\n  }\n\n  get selectedMethod() {\n    return this._selectedMethod;\n  }\n\n  set selectedMethod(m) {\n    _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(this._cspec.hasMethod(m), \"selecting a method not in the constraint\");\n    this._selectedMethod = m;\n\n    for (let i of m.ins()) this._used[i] = true;\n  }\n\n  clearSelectedMethod() {\n    this._selectedMethod = null;\n  }\n\n  isEnforced() {\n    return this._selectedMethod != null;\n  }\n\n  isOutputVariable(v) {\n    if (this.selectedMethod == null) return false;else return this.selectedMethod.isOut(this.v2i(v));\n  }\n\n  isInputVariable(v) {\n    if (this.selectedMethod == null) return false;else return this.selectedMethod.isIn(this.v2i(v));\n  }\n\n  isNonOutputVariable(v) {\n    if (this.selectedMethod == null) return false;else return this.selectedMethod.isNonOut(this.v2i(v));\n  }\n\n  downstreamVariables() {\n    if (this.selectedMethod == null) return _utilities__WEBPACK_IMPORTED_MODULE_4__[\"mkEmptyIterable\"]();else return this.selectedMethod.vOuts(this._vars);\n  }\n\n  downstreamAndUndetermined() {\n    if (this.selectedMethod == null) return this._vars;else return this.selectedMethod.vOuts(this._vars);\n  }\n\n  upstreamVariables() {\n    if (this.selectedMethod == null) return _utilities__WEBPACK_IMPORTED_MODULE_4__[\"mkEmptyIterable\"]();else return this.selectedMethod.vNonOuts(this._vars);\n  }\n\n  upstreamAndUndetermined() {\n    if (this.selectedMethod == null) return this._vars;else return this.selectedMethod.vNonOuts(this._vars);\n  }\n\n  _initPruningData() {\n    this._viableMethods = new Set();\n    this._forcedVariables = new Set();\n    this._outCounts = Array(this.nvars).fill(0);\n\n    for (let m of this.methods()) {\n      this._viableMethods.add(m);\n\n      for (let i of m.outs()) this._outCounts[i] += 1;\n    }\n\n    const vmcount = this._viableMethods.size;\n\n    for (let i = 0; i < this.nvars; ++i) {\n      if (this._outCounts[i] === vmcount) this._forcedVariables.add(i);\n    }\n  }\n\n  _makeMethodViable(m) {\n    _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(!this._viableMethods.has(m), \"making a method viable twice\");\n    _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(this.hasMethod(m), \"unknown method\");\n    let vmcountOld = this._viableMethods.size;\n\n    this._viableMethods.add(m);\n\n    let newlyUnforced = [];\n\n    for (let i of m.outs()) this._outCounts[i] += 1;\n\n    for (let i of m.nonOuts()) {\n      if (this._outCounts[i] === vmcountOld) {\n        this._forcedVariables.delete(i);\n\n        newlyUnforced.push(i);\n      }\n    }\n\n    return newlyUnforced;\n  } // returns the indices of the newly forced variables\n\n\n  _makeMethodNonviable(m) {\n    _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(this._viableMethods.has(m), \"making a method nonviable twice\");\n    _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(this._viableMethods.size >= 2, \"trying to make the last viable method nonviable\");\n\n    this._viableMethods.delete(m);\n\n    let vmcount = this._viableMethods.size;\n    let newlyForced = [];\n\n    for (let i of m.outs()) this._outCounts[i] -= 1;\n\n    for (let i of m.nonOuts()) {\n      if (this._outCounts[i] === vmcount) {\n        this._forcedVariables.add(i);\n\n        newlyForced.push(i);\n      }\n    } // FIXME: remove at some point\n\n\n    for (let i = 0; i < this._outCounts.length; ++i) _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(this._outCounts[i] >= 0);\n\n    return newlyForced;\n  }\n\n  _makeMethodsNonviableByVariable(v) {\n    let vi = this.v2i(v);\n    if (this._forcedVariables.has(vi)) return _utilities__WEBPACK_IMPORTED_MODULE_4__[\"mkEmptyIterable\"]();\n    let newlyForced = new Set();\n\n    for (let m of _utilities__WEBPACK_IMPORTED_MODULE_4__[\"filter\"](m => m.isOut(vi), this._viableMethods)) {\n      for (let vv of _utilities__WEBPACK_IMPORTED_MODULE_4__[\"map\"](v => this.i2v(v), this._makeMethodNonviable(m))) {\n        newlyForced.add(vv);\n      }\n    }\n\n    return newlyForced;\n  }\n\n}\nclass ConstraintSystem {\n  // FIXME: move to a better place\n  allConstraints() {\n    return _utilities__WEBPACK_IMPORTED_MODULE_4__[\"join\"]([this._musts, this._optionals.entries()]);\n  }\n\n  addComponent(c) {\n    return c.connectSystem(this);\n  }\n\n  removeComponent(c) {\n    if (c.system != this) {\n      console.warn(`Tried to remove component ${c._name} from a constraint system in which it does not exist.`);\n      return false;\n    }\n\n    return c.disconnectSystem();\n  }\n\n  prettyPrint() {\n    let s = \"-- musts --\\n\";\n\n    for (let m of this._musts) s += m.prettyPrint();\n\n    s += \"-- optionals --\\n\";\n\n    for (let m of this._optionals.entries()) s += m.prettyPrint();\n\n    return s;\n  }\n\n  constructor() {\n    this._optionals = new _utilities__WEBPACK_IMPORTED_MODULE_4__[\"PriorityList\"]();\n    this._musts = new Set();\n    this._dirty = new Set();\n    this._v2cs = new _utilities__WEBPACK_IMPORTED_MODULE_4__[\"OneToManyMap\"]();\n    this._usg = new UpstreamSolutionGraph(this);\n    this._dsg = new DownstreamSolutionGraph(this);\n  }\n\n  update() {\n    this.plan(this.allConstraints()); // FIXME: a little wasteful since plan iterates\n    // all vars of all constraints, and same vars appear many time. OK for now\n\n    this.solveFromConstraints(this.allConstraints());\n  }\n\n  variables() {\n    return this._v2cs.keys();\n  }\n\n  constraints(v) {\n    return this._v2cs.values(v);\n  }\n\n  *allConstraints() {\n    for (let c of this._musts) yield c;\n\n    for (let c of this._optionals.entries()) yield c;\n  }\n\n  isMust(c) {\n    return this._musts.has(c);\n  }\n\n  isOptional(c) {\n    return !this._musts.has(c);\n  }\n\n  addConstraint(c) {\n    for (let v of c.variables()) this._v2cs.add(v, c);\n\n    if (c._optional) this._optionals.pushBack(c);else this._musts.add(c);\n\n    this._dirty.add(c);\n  }\n\n  removeConstraint(c) {\n    for (let v of c.variables()) {\n      this._v2cs.remove(v, c);\n\n      if (this._v2cs.count(v) == 0) this._v2cs.removeKey(v);\n    }\n\n    if (c._optional) this._optionals.remove(c);else this._musts.delete(c);\n\n    this._dirty.delete(c);\n  }\n\n  setDirty(c) {\n    this._dirty.add(c);\n  }\n\n  gatherUpstreamConstraints(vs) {\n    let r = _utilities__WEBPACK_IMPORTED_MODULE_4__[\"filter\"](v => isConstraint(v), Object(_graph_algorithms__WEBPACK_IMPORTED_MODULE_0__[\"reverseTopoSortFrom\"])(this._usg, vs));\n    return r; // cast is to shut up flowtype\n  }\n\n  gatherDownstreamConstraints(vs) {\n    let r = _utilities__WEBPACK_IMPORTED_MODULE_4__[\"filter\"](v => isConstraint(v), Object(_graph_algorithms__WEBPACK_IMPORTED_MODULE_0__[\"reverseTopoSortFrom\"])(this._dsg, vs));\n    return r;\n  }\n\n  gatherDownstreamVariables(vs) {\n    let r = _utilities__WEBPACK_IMPORTED_MODULE_4__[\"filter\"](v => isVariable(v), Object(_graph_algorithms__WEBPACK_IMPORTED_MODULE_0__[\"reverseTopoSortFrom\"])(this._dsg, vs));\n    return r;\n  }\n\n  promoteVariable(v) {\n    this.promoteConstraint(this.getStay(v));\n  }\n\n  promoteConstraint(c) {\n    this._optionals.promote(c);\n  }\n\n  demoteConstraint(c) {\n    this._optionals.demote(c);\n  }\n\n  strength(c) {\n    if (this.isMust(c)) return this._optionals.highestPriority + 1;else return this._optionals.priority(c);\n  }\n\n  getStay(v) {\n    for (let c of this._v2cs.values(v)) {\n      if (c.name == \"__stay__\" + v.name) return c;\n    }\n\n    _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(false, \"Variable's stay constraint does not exists\");\n    return null;\n  }\n\n  planDirty() {\n    return this.plan(this._dirty);\n  }\n\n  updateDirty() {\n    this.planDirty();\n    this.executeDirty();\n\n    this._dirty.clear();\n  }\n\n  plan(toEnforce) {\n    let vs = _utilities__WEBPACK_IMPORTED_MODULE_4__[\"join\"](_utilities__WEBPACK_IMPORTED_MODULE_4__[\"map\"](c => c.variables(), toEnforce)); // all variables from all constraints in the enforce queues\n\n    let constraintsThatNeedNewPlan = this.gatherUpstreamConstraints(vs); // gather all constraints upstream from these variables.\n    // This includes all constraints reachable through any method \n    // of an unenforced constraint. Quickplan does not do this since\n    // it has a separate reenforcing phase, but we put all constraints\n    // that may need to change into one bunch.\n    // The point is that unenforced constraints may become enforceable,\n    // and then they may force resolving of their upstream constraints.\n\n    let enforceable = new Set(); // this is the set of constraints that is determined to be enforceable\n\n    let forcedSet = new Set(); // this is the set of variables that are forced with the enforceable\n    // methods\n\n    let opts = new _utilities__WEBPACK_IMPORTED_MODULE_4__[\"BinaryHeap\"]((c1, c2) => this.strength(c1) > this.strength(c2)); // initialize simple planner with all must constraints (should be enforceable)\n\n    let sp = new SimplePlanner();\n    _utilities__WEBPACK_IMPORTED_MODULE_4__[\"forEach\"](c => {\n      c.clearSelectedMethod();\n\n      c._initPruningData(); // FIXME: maybe just make methods viable again\n\n\n      if (this.isMust(c)) {\n        enforceable.add(c);\n        sp.addConstraint(c);\n      } else {\n        opts.push(c);\n      }\n    }, constraintsThatNeedNewPlan); // \n\n    _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(sp.plan(), \"no plan for must constraints\"); // the conflicting constraints are in sp.constraints()\n\n    while (!opts.empty()) {\n      let opt = opts.pop();\n\n      switch (sp.extendPlanIfPossible(opt, forcedSet)) {\n        case false:\n          break;\n\n        case true:\n          enforceable.add(opt);\n\n          this._prune(opt, enforceable, forcedSet);\n\n          break;\n\n        case null:\n          sp.clear();\n\n          for (let c of enforceable) {\n            //            c.clearSelectedMethod();\n            sp.addConstraint(c);\n          }\n\n          sp.addConstraint(opt);\n\n          if (sp.plan()) {\n            enforceable.add(opt);\n\n            this._prune(opt, enforceable, forcedSet);\n          } else {\n            sp.removeConstraint(opt);\n            opt.clearSelectedMethod();\n            sp.undoChangesAfterFailedPlan();\n          }\n\n          break;\n      }\n    }\n\n    return enforceable;\n  } // prune starting from constraint c\n\n\n  _prune(c, constraintsOfInterest, forcedSet) {\n    let inspected = new Set(); // initialize worklist with the variables that c forces\n\n    let worklist = Array.from(c._forcedVariables, i => c.i2v(i));\n\n    while (worklist.length > 0) {\n      let v = worklist.pop();\n      inspected.add(v);\n      if (forcedSet.has(v)) continue;\n      forcedSet.add(v); // inspect all constraints connected to v\n\n      for (let cn of this.constraints(v)) {\n        if (!cn.isEnforced()) continue;\n        if (!constraintsOfInterest.has(cn)) continue;\n\n        for (let vv of cn._makeMethodsNonviableByVariable(v)) {\n          // vv iterates over the set of newly forced variables\n          if (!inspected.has(vv)) {\n            worklist.push(vv);\n          }\n        }\n      }\n    }\n  }\n\n  solveFromConstraints(cs) {\n    this.solve(_utilities__WEBPACK_IMPORTED_MODULE_4__[\"join\"](_utilities__WEBPACK_IMPORTED_MODULE_4__[\"map\"](c => c.downstreamVariables(), cs)));\n  }\n\n  solve(vs) {\n    let cs = [];\n\n    for (let v of vs) {\n      let c = this.getSourceConstraint(v);\n      if (c != null) cs.push(c);\n    } // Find the constraints that write to variables in vs.\n    // Usually these are stay constraints, but could be other constraints if the\n    // variable cannot stay in the chosen plan\n    // NOTE: every variable must have a stay or other constraint that writes to it. Otherwise\n    // constraints downstream from it are not found.\n\n\n    let dsc = Array.from(this.gatherDownstreamConstraints(cs)).reverse();\n\n    for (let c of dsc) this.scheduleConstraint(c);\n  }\n\n  executeDirty() {\n    let dsc = Array.from(this.gatherDownstreamConstraints(this._dirty)).reverse();\n\n    for (let c of dsc) this.scheduleConstraint(c);\n  }\n\n  getSourceConstraint(v) {\n    for (let c of this._v2cs.values(v)) {\n      if (c.isOutputVariable(v)) return c;\n    }\n\n    return null;\n  }\n\n  scheduleConstraint(c) {\n    if (!c.isEnforced()) return; // if there is no selected method, there  is nothing to schedule\n\n    let m = c.selectedMethod;\n    let inDeferreds = Array.from(c.ins(m), v => v._activation); // push new activations to all outputs, but remember the previous onces\n\n    let prevActs = [];\n    _utilities__WEBPACK_IMPORTED_MODULE_4__[\"forEach\"](v => {\n      prevActs.push(v._activation);\n      v.pushNewActivation();\n    }, c.outs(m));\n    let outDeferreds = Array.from(c.outs(m), v => v._activation);\n    new _computation_graph__WEBPACK_IMPORTED_MODULE_1__[\"MethodActivation\"](m.code, m._promiseMask).execute(inDeferreds, outDeferreds); // only release the old activations of outputs here; after a new method activation has been executed                     \n\n    _utilities__WEBPACK_IMPORTED_MODULE_4__[\"forEach\"](v => _utilities__WEBPACK_IMPORTED_MODULE_4__[\"release\"](v), prevActs);\n  } // touch order is fixed, last parameter gets highest\n\n\n  scheduleCommand(ins, outs, f) {\n    let inDeferreds = Array.from(ins, v => v._activation);\n    let outArray = Array.from(outs); // push new activations to all outputs, but remember the previous onces\n\n    let prevActs = [];\n    _utilities__WEBPACK_IMPORTED_MODULE_4__[\"forEach\"](v => {\n      prevActs.push(v._activation);\n      v.pushNewActivation();\n    }, outArray);\n    let outDeferreds = Array.from(outArray, v => v._activation);\n    new _computation_graph__WEBPACK_IMPORTED_MODULE_1__[\"MethodActivation\"](f, Array(inDeferreds.length).fill(false)).execute(inDeferreds, outDeferreds); // only release the old activations of outputs here; after a new method activation has been executed                     \n\n    _utilities__WEBPACK_IMPORTED_MODULE_4__[\"forEach\"](v => _utilities__WEBPACK_IMPORTED_MODULE_4__[\"release\"](v), prevActs);\n    outArray.forEach(v => this.promoteVariable(v));\n    let enforceable = this.plan(_utilities__WEBPACK_IMPORTED_MODULE_4__[\"map\"](v => this.getStay(v), outArray));\n    this.solve(outArray);\n  }\n\n}\nclass DownstreamSolutionGraph {\n  constructor(system) {\n    this._system = system;\n  }\n\n  adjacentOutVertices(v) {\n    if (isConstraint(v)) {\n      return v.downstreamAndUndetermined();\n    } else return _utilities__WEBPACK_IMPORTED_MODULE_4__[\"filter\"](c => c.isNonOutputVariable(v) || !c.isEnforced(), this._system._v2cs.values(v));\n  }\n\n  outDegree(v) {\n    if (isConstraint(v)) {\n      return v.selectedMethod != null ? v.selectedMethod.nOuts() : 0;\n    } else {\n      return _utilities__WEBPACK_IMPORTED_MODULE_4__[\"count\"](this.adjacentOutVertices(v)); // not constant time\n    }\n  }\n\n}\nclass UpstreamSolutionGraph {\n  constructor(system) {\n    this._system = system;\n  }\n\n  adjacentOutVertices(v) {\n    if (isConstraint(v)) {\n      return v.upstreamAndUndetermined();\n    } else return _utilities__WEBPACK_IMPORTED_MODULE_4__[\"filter\"](c => c.isOutputVariable(v) || !c.isEnforced(), this._system._v2cs.values(v));\n  }\n\n  outDegree(v) {\n    if (isConstraint(v)) {\n      return v.selectedMethod != null ? v.selectedMethod.nNonOuts() : 0;\n    } else {\n      return _utilities__WEBPACK_IMPORTED_MODULE_4__[\"count\"](this.adjacentOutVertices(v)); // not constant time\n    }\n  }\n\n}\nclass SimplePlanner {\n  // record if selected method changes, so we can undo\n  // to a previous solution\n  constructor() {\n    this._v2cs = new _utilities__WEBPACK_IMPORTED_MODULE_4__[\"OneToManyMap\"]();\n    this._freeVars = new Set();\n    this._forcedByPlan = new Map();\n    this._changeList = [];\n  }\n\n  addConstraint(c) {\n    for (let v of c.variables()) {\n      this._v2cs.add(v, c);\n\n      switch (this._v2cs.count(v)) {\n        case 1:\n          this._freeVars.add(v);\n\n          break;\n\n        case 2:\n          this._freeVars.delete(v);\n\n          break;\n      }\n    }\n  }\n\n  removeConstraint(c) {\n    for (let v of c.variables()) {\n      this._v2cs.remove(v, c);\n\n      switch (this._v2cs.count(v)) {\n        case 0:\n          this._freeVars.delete(v);\n\n          this._v2cs.removeKey(v);\n\n          break;\n\n        case 1:\n          this._freeVars.add(v);\n\n          break;\n      }\n    }\n  }\n\n  clear() {\n    this._v2cs.clear();\n\n    this._freeVars.clear(); //    this._forcedByPlan.clear();\n\n  }\n\n  plan() {\n    let foundFree = true;\n\n    while (foundFree) {\n      foundFree = false;\n\n      for (let [c, m] of this.freeMethods()) {\n        foundFree = true;\n        let oldm = c.selectedMethod;\n\n        if (oldm !== m && oldm != null) {\n          this._changeList.push([c, oldm]);\n\n          for (let v of c.outs(oldm)) this._forcedByPlan.delete(v); // clear old methods forced by data\n\n        }\n\n        c.selectedMethod = m;\n\n        for (let v of c.outs(m)) this._forcedByPlan.set(v, m);\n\n        this.removeConstraint(c);\n      }\n    }\n\n    if (this._v2cs.countKeys() === 0) {\n      this._changeList = []; // no undo info after successful plan\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  undoChangesAfterFailedPlan() {\n    for (let [c, m] of this._changeList) {\n      let oldm = c.selectedMethod;\n\n      if (oldm != null) {\n        for (let v of c.outs(oldm)) this._forcedByPlan.delete(v);\n      }\n\n      for (let v of c.outs(m)) this._forcedByPlan.set(v, m);\n\n      c.selectedMethod = m;\n    }\n  }\n\n  extendPlanIfPossible(c, forcedSet) {\n    // FIXME: special case for stays for speed\n    if (_utilities__WEBPACK_IMPORTED_MODULE_4__[\"every\"](m => _utilities__WEBPACK_IMPORTED_MODULE_4__[\"some\"](v => forcedSet.has(v), c.outs(m)), c._viableMethods)) return false; // if every method has some output to a forced variable,\n    // the constraint is unenforceable\n\n    if (_utilities__WEBPACK_IMPORTED_MODULE_4__[\"every\"](v => !this._forcedByPlan.has(v), c.variables())) {\n      let m = _utilities__WEBPACK_IMPORTED_MODULE_4__[\"first\"](c._viableMethods); // just pick the first (likely only method) for the plan\n\n      _hdconsole__WEBPACK_IMPORTED_MODULE_2__[\"hdconsole\"].assert(m != null, \"constraint has no viable methods\");\n      if (m == null) return false; // FIXME: think if asserting is the best way: could just return false?\n\n      c.selectedMethod = m;\n\n      for (let v of c.outs(m)) {\n        this._forcedByPlan.set(v, m);\n      } // Methods that have an output to a forcedByPlan variable\n      // cannot be added to the plan. But methods that have\n      // nonOutputs that are forced, could lead to a cycle.\n      // So we ban all constraints that have have variables\n      // forced by the current plan. \n      // This could be detected, but instead we just say \n      // that it is unusure if plan is possible or not.\n      // The usual case\n      // of calling this function is with stay constraints,\n      // and then cycles are not an issue.\n\n\n      return true;\n    }\n\n    return null; // don't know if c can be enforced, must do planning\n  }\n\n  *freeMethods() {\n    let seen = new Set(); // check constraint only once\n\n    for (let v of this._freeVars) {\n      for (let c of this._v2cs.values(v)) {\n        // FIXME: this loop should only happen once, because v is free.\n        // right?\n        if (!seen.has(c)) {\n          seen.add(c);\n\n          for (let m of c.viableMethods()) {\n            if (_utilities__WEBPACK_IMPORTED_MODULE_4__[\"every\"](v => this._freeVars.has(v), c.outs(m))) {\n              yield [c, m];\n              break; // only generate the first method per constraint\n            }\n          }\n        }\n      }\n    }\n  }\n\n  firstFreeMethod() {\n    return _utilities__WEBPACK_IMPORTED_MODULE_4__[\"first\"](this.freeMethods());\n  }\n\n  constraints() {\n    let cs = new Set();\n\n    for (let v of this._v2cs.keys()) {\n      for (let c of this._v2cs.values(v)) cs.add(c);\n    }\n\n    return cs;\n  }\n\n}\nconst stayConstraintSpec = new ConstraintSpec([new Method(1, [0], [0], [maskNone], a => a, \"stay\")]);\nfunction enforceStayMethod(stay) {\n  stay.selectedMethod = _utilities__WEBPACK_IMPORTED_MODULE_4__[\"first\"](stay._cspec._methods);\n}\nfunction isStay(c) {\n  return c._cspec === stayConstraintSpec;\n}\n\n//# sourceURL=webpack://hd/./src/constraint-system.js?");

/***/ }),

/***/ "./src/graph-algorithms.js":
/*!*********************************!*\
  !*** ./src/graph-algorithms.js ***!
  \*********************************/
/*! exports provided: reverseTopoSort, reverseTopoSortFrom, dfsVisit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reverseTopoSort\", function() { return reverseTopoSort; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reverseTopoSortFrom\", function() { return reverseTopoSortFrom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dfsVisit\", function() { return dfsVisit; });\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ \"./src/utilities.js\");\n// export type { DfsAdjacencyVisitor };\n\n\n\nfunction dfsVisit(g, vs, visitor, visited) {\n  if (visited == null) visited = new Set();\n  let stack = [];\n  let it = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__[\"iterableToIterator\"])(vs);\n\n  while (true) {\n    let n = it.next();\n\n    if (n.done) {\n      if (stack.length === 0) break; // returns\n\n      let v;\n      [v, it] = stack.pop();\n      visitor.finishVertex(v);\n      continue;\n    }\n\n    let v = n.value;\n\n    if (visited.has(v)) {\n      continue;\n    }\n\n    visitor.discoverVertex(v);\n    visited.add(v);\n    stack.push([v, it]);\n    it = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__[\"iterableToIterator\"])(g.adjacentOutVertices(v));\n  }\n}\n\nfunction reverseTopoSort(g) {\n  return reverseTopoSortFrom(g, g.vertices());\n}\n\nclass TopoVisitor {\n  constructor() {\n    this.result = [];\n  }\n\n  discoverVertex(v) {}\n\n  finishVertex(v) {\n    this.result.push(v);\n  }\n\n}\n\nfunction reverseTopoSortFrom(g, vs) {\n  let vis = new TopoVisitor();\n  dfsVisit(g, vs, vis);\n  return vis.result;\n}\n\n//# sourceURL=webpack://hd/./src/graph-algorithms.js?");

/***/ }),

/***/ "./src/hdconsole.js":
/*!**************************!*\
  !*** ./src/hdconsole.js ***!
  \**************************/
/*! exports provided: HdConsole, hdconsole, HdError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HdConsole\", function() { return HdConsole; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hdconsole\", function() { return hdconsole; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HdError\", function() { return HdError; });\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ \"./src/utilities.js\");\n\nclass HdConsole {\n  constructor(name) {\n    this._name = name;\n    this.off();\n  }\n\n  off() {\n    this.log = (...args) => {};\n\n    this.warn = (...args) => {};\n\n    this.error = (...args) => {};\n\n    this.assert = (...args) => {};\n  }\n\n  errorsOnly() {\n    this.off();\n    this.error = console.error;\n    this.assert = console.assert;\n  }\n\n  on() {\n    this.log = console.log;\n    this.warn = console.warn;\n    this.error = console.error;\n    this.assert = console.assert;\n  }\n\n}\nvar hdconsole = new HdConsole(\"HotDrink\");\nclass HdError extends Error {\n  constructor(msg, ...params) {\n    super(msg, ...params); // Maintains proper stack trace for where our error was thrown (only available on V8)\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, HdError);\n    }\n\n    this.name = 'HdError';\n  }\n\n}\n\n//# sourceURL=webpack://hd/./src/hdconsole.js?");

/***/ }),

/***/ "./src/lexing-tools.js":
/*!*****************************!*\
  !*** ./src/lexing-tools.js ***!
  \*****************************/
/*! exports provided: Position, isWhitespace, isDigit, isAlpha, isAlphaPlus, isAlphaNum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Position\", function() { return Position; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWhitespace\", function() { return isWhitespace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isDigit\", function() { return isDigit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isAlpha\", function() { return isAlpha; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isAlphaPlus\", function() { return isAlphaPlus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isAlphaNum\", function() { return isAlphaNum; });\n// [[file:~/git/hd4/org/lexing-tools.org::*Tangle][Tangle:1]]\n// [[file:~/git/hd4/org/lexing-tools.org::*Position%20type][]]\nclass Position {\n  // 0-indexed position on the entire input string \n  // 1-indexed\n  // 0-indexed\n  // name of a source (file) the position refers to\n  constructor(pos, row, col, source) {\n    this._pos = pos;\n    this._row = row;\n    this._col = col;\n    if (source !== undefined) this._source = source;\n  }\n\n  get pos() {\n    return this._pos;\n  }\n\n  get row() {\n    return this._row;\n  }\n\n  get col() {\n    return this._col;\n  }\n\n  get source() {\n    return this._source != null ? this._source : \"-\";\n  }\n\n  toString() {\n    return this.source + \":\" + this.row + \":\" + this.col;\n  }\n\n  advance(str) {\n    for (let i = 0; i < str.length; ++i) {\n      if (str[i] === '\\n') {\n        this._row++;\n        this._col = 0;\n      } else {\n        this._col++;\n      }\n\n      this._pos++;\n    }\n  }\n\n  clone() {\n    let p = new Position(this.pos, this.row, this.col);\n    if (this.hasOwnProperty('_source')) p._source = this._source; // optional parameters do not accept null,\n    // therefore we set _source after construction\n    // We only set it if the property exists in the source;\n    //   otherwise we might get _source to exist but be undefined in target,\n    //   and then source and target would not compare (deep)equal\n\n    return p;\n  }\n\n}\n; // ends here\n// [[file:~/git/hd4/org/lexing-tools.org::*Character%20predicates][]]\n\nfunction isWhitespace(c) {\n  switch (c) {\n    case ' ':\n    case '\\t':\n    case '\\r':\n    case '\\n':\n      return true;\n\n    default:\n      return false;\n  }\n}\nfunction isDigit(c) {\n  return c >= '0' && c <= '9';\n}\nfunction isAlpha(c) {\n  return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';\n}\nfunction isAlphaPlus(c) {\n  return isAlpha(c) || c === '_' || c === '$';\n}\nfunction isAlphaNum(c) {\n  return isAlphaPlus(c) || isDigit(c);\n} // ends here\n// Tangle:1 ends here\n\n//# sourceURL=webpack://hd/./src/lexing-tools.js?");

/***/ }),

/***/ "./src/observable.js":
/*!***************************!*\
  !*** ./src/observable.js ***!
  \***************************/
/*! exports provided: mkObserver, Observable, HdSubscription, SubscriptionObserver, Subject, ReplaySubject, BehaviorSubject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkObserver\", function() { return mkObserver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Observable\", function() { return Observable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HdSubscription\", function() { return HdSubscription; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SubscriptionObserver\", function() { return SubscriptionObserver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Subject\", function() { return Subject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReplaySubject\", function() { return ReplaySubject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorSubject\", function() { return BehaviorSubject; });\n// [[file:~/git/hd4/org/observable.org::*Tangle][Tangle:1]]\n// [[file:~/git/hd4/org/observable.org::*Observer%20interface][]]\n// ends here\n// [[file:~/git/hd4/org/observable.org::*Subscription][]]\n// ends here\n// [[file:~/git/hd4/org/observable.org::*Subscription][]]\n// create an observer from separate functions\nfunction mkObserver(obs, err, complete) {\n  let observer;\n\n  if (typeof obs === 'function') {\n    observer = {};\n    observer.next = obs;\n    if (err != null) observer.error = err;\n    if (complete != null) observer.complete = complete;\n  } else observer = obs;\n\n  return observer;\n}\nclass Observable {\n  constructor(subscriber) {\n    this._subscriber = subscriber;\n  }\n\n  subscribe(obs, err, complete) {\n    let observer = mkObserver(obs, err, complete);\n    let subscription = new HdSubscription(observer);\n\n    try {\n      if (observer.start != null) observer.start(subscription);\n    } catch (e) {// FIXME: HostReportError(e)\n    }\n\n    if (subscription.closed) return subscription;\n    let subscriptionObserver = new SubscriptionObserver(subscription);\n\n    try {\n      let cleanup = this._subscriber(subscriptionObserver);\n\n      if (typeof cleanup === 'object') cleanup = () => cleanup.unsubscribe(); // must be a Subscription object\n\n      subscription._cleanup = cleanup;\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (subscription.closed) subscription.cleanup();\n    return subscription;\n  } // FIXME Implement later\n  // [Symbol.observable]() : Observable;\n\n\n  static of(...items) {\n    return new Observable(observer => {\n      for (let item of items) {\n        observer.next(item);\n        if (observer.closed) return;\n      }\n\n      observer.complete();\n    });\n  } // FIXME Implement later\n  // static from(obs: Observable<T> | Iterable<T>) : Observable<T> {\n  //   \n  // }   \n\n\n  filter(p) {\n    return new Observable(observer => {\n      let o = mkObserver(observer);\n      if (o.next == null) o = {\n        next: e => {}\n      };\n      let s = this.subscribe(e => {\n        if (p(e) == true) o.next(e);\n      });\n      return s;\n    });\n  }\n\n  map(f) {\n    return new Observable(observer => {\n      let o = mkObserver(observer);\n      if (o.next == null) o = {\n        next: e => {}\n      };\n      let s = this.subscribe(e => {\n        let o = mkObserver(observer);\n        o.next(f(e));\n      });\n      return s;\n    });\n  }\n\n}\nclass HdSubscription {\n  constructor(observer) {\n    this._observer = observer;\n    this._cleanup = undefined;\n  }\n\n  unsubscribe() {\n    this._observer = undefined;\n    this.cleanup();\n  }\n\n  get closed() {\n    return this._observer === undefined;\n  }\n\n  cleanup() {\n    const cUp = this._cleanup;\n    if (cUp === undefined) return;\n    this._cleanup = undefined;\n\n    try {\n      cUp();\n    } catch (e) {\n      /* FIXME: HostReportErrors(e) */\n    }\n  }\n\n}\nclass SubscriptionObserver {\n  constructor(s) {\n    this._subscription = s;\n  }\n\n  get closed() {\n    return this._subscription.closed;\n  }\n\n  next(value) {\n    let s = this._subscription; // appeasing flowtype\n\n    if (s.closed) return;\n\n    if (s._observer.next != null) {\n      try {\n        s._observer.next(value);\n      } catch (e) {\n        /* FIXME: HostReportErrors(e) */\n      }\n    }\n  }\n\n  error(errorValue) {\n    let s = this._subscription; // appeasing flowtype\n\n    if (s.closed) return; // FIXME, why not test this.closed ?\n\n    if (s._observer.error != null) {\n      try {\n        s._observer.error(errorValue);\n      } catch (e) {\n        /* FIXME: HostReportErrors(e) */\n      }\n    }\n\n    this._subscription.cleanup();\n  }\n\n  complete() {\n    let s = this._subscription; // appeasing flowtype\n\n    if (s.closed) return;\n\n    if (s._observer.complete != null) {\n      try {\n        s._observer.complete();\n      } catch (e) {\n        /* FIXME: HostReportErrors(e) */\n      }\n    }\n\n    this._subscription.cleanup();\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/observable.org::*Subjects][]]\n\nclass Subject extends Observable {\n  constructor(f = o => {}) {\n    let state = {\n      observers: new Set(),\n      done: false\n    };\n    super(o => {\n      if (!state.done) state.observers.add(o);\n      f(o);\n      return () => state.observers.delete(o); // this is a no-op if done==true\n    });\n    this._subjectState = state;\n  }\n\n  sendNext(v) {\n    if (this._subjectState.done) return;\n\n    for (const obs of this._subjectState.observers) obs.next(v);\n  }\n\n  sendError(e) {\n    if (this._subjectState.done) return;\n    this._subjectState.done = true;\n\n    for (const obs of this._subjectState.observers) obs.error(e);\n  }\n\n  sendComplete() {\n    if (this._subjectState.done) return;\n    this._subjectState.done = true;\n\n    for (const obs of this._subjectState.observers) obs.complete();\n  }\n\n  get nObservers() {\n    return this._subjectState.observers.size;\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/observable.org::*Subjects][]]\n\nclass ReplaySubject extends Subject {\n  constructor(limit = 1) {\n    let state = {\n      past: [],\n      pastLimit: limit,\n      isCompleted: false,\n      isError: false\n    };\n    super(o => {\n      for (let v of state.past) o.next(v);\n\n      if (state.isError) o.error(state.error);else if (state.isCompleted) o.complete();\n    });\n    this._replaySubjectState = state;\n  }\n\n  sendNext(v) {\n    this._replaySubjectState.past.push(v);\n\n    if (this._replaySubjectState.past.length > this._replaySubjectState.pastLimit) {\n      this._replaySubjectState.past.shift();\n    }\n\n    super.sendNext(v);\n  }\n\n  sendError(e) {\n    this._replaySubjectState.isError = true;\n    this._replaySubjectState.error = e;\n    super.sendError(e);\n  }\n\n  sendComplete() {\n    this._replaySubjectState.isCompleted = true;\n    super.sendComplete();\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/observable.org::*Subjects][]]\n\nclass BehaviorSubject extends ReplaySubject {\n  constructor(v) {\n    super(1);\n\n    this._replaySubjectState.past.push(v);\n  }\n\n} // ends here\n// Tangle:1 ends here\n\n//# sourceURL=webpack://hd/./src/observable.js?");

/***/ }),

/***/ "./src/parsing.js":
/*!************************!*\
  !*** ./src/parsing.js ***!
  \************************/
/*! exports provided: ParseState, mkParseState, ok, fail, failF, ParseError, item, peekItem, failure, ret, eof, sat, pChar, pChars, alphaPlus, alphaNum, digit, many, many1, exactString, lineComment, blockComment, onews, manyws, pBind, pBind_, opt, ignore, lift, lift2, lift3, lift4, lift5, go, inBetween, parens, oneOf, pNot, until, notFollowedBy, pTry, must, named, token, word, identifier, nat, sepList, currentPos, context, hdl, pSplice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseState\", function() { return ParseState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkParseState\", function() { return mkParseState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ok\", function() { return ok; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fail\", function() { return fail; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"failF\", function() { return failF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseError\", function() { return ParseError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"item\", function() { return item; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"peekItem\", function() { return peekItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"failure\", function() { return failure; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ret\", function() { return ret; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eof\", function() { return eof; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sat\", function() { return sat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pChar\", function() { return pChar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pChars\", function() { return pChars; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"alphaPlus\", function() { return alphaPlus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"alphaNum\", function() { return alphaNum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"digit\", function() { return digit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"many\", function() { return many; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"many1\", function() { return many1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactString\", function() { return exactString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lineComment\", function() { return lineComment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"blockComment\", function() { return blockComment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onews\", function() { return onews; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"manyws\", function() { return manyws; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pBind\", function() { return pBind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pBind_\", function() { return pBind_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"opt\", function() { return opt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ignore\", function() { return ignore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lift\", function() { return lift; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lift2\", function() { return lift2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lift3\", function() { return lift3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lift4\", function() { return lift4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lift5\", function() { return lift5; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"go\", function() { return go; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inBetween\", function() { return inBetween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parens\", function() { return parens; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"oneOf\", function() { return oneOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pNot\", function() { return pNot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"until\", function() { return until; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"notFollowedBy\", function() { return notFollowedBy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pTry\", function() { return pTry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"must\", function() { return must; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"named\", function() { return named; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"token\", function() { return token; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"word\", function() { return word; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identifier\", function() { return identifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nat\", function() { return nat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sepList\", function() { return sepList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"currentPos\", function() { return currentPos; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"context\", function() { return context; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hdl\", function() { return hdl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pSplice\", function() { return pSplice; });\n/* harmony import */ var _src_lexing_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/lexing-tools */ \"./src/lexing-tools.js\");\n/* harmony import */ var _src_peek_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/peek-iterator */ \"./src/peek-iterator.js\");\n/* harmony import */ var _src_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/utilities */ \"./src/utilities.js\");\n/* harmony import */ var _src_hdconsole__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/hdconsole */ \"./src/hdconsole.js\");\n\n\n\n\nclass ParseState {\n  constructor(input, splices = [], pos = new _src_lexing_tools__WEBPACK_IMPORTED_MODULE_0__[\"Position\"](0, 1, 0)) {\n    this._input = new _src_peek_iterator__WEBPACK_IMPORTED_MODULE_1__[\"default\"](input);\n    this._context = [];\n    this._splices = splices;\n    this.pos = pos;\n  }\n\n  pushContext(str) {\n    this._context.push([str, this.pos.clone()]);\n  }\n\n  popContext() {\n    this._context.pop();\n  }\n\n  checkpoint() {\n    this._input.checkpoint(this.pos.clone());\n  }\n\n  forgetCheckpoint() {\n    this._input.forgetCheckpoint();\n  }\n\n  resetCheckpoint() {\n    this.pos = this._input.reset();\n  }\n\n  peek() {\n    return this._input.peek();\n  }\n\n  advance() {\n    let i = this._input.next();\n\n    if (!i.done) this.pos.advance(i.value);\n    return i.value;\n  }\n\n  getSplice(i) {\n    return this._splices[i];\n  }\n\n  parseErrorF(expF, msg) {\n    // extract the topmost context, if any\n    let ctxName, ctxPos;\n    if (this._context.length > 0) [ctxName, ctxPos] = this._context[this._context.length - 1];\n    this.checkpoint();\n    let r = lift((spc, nonspc) => spc + nonspc.join(''), manyws, many(sat(c => !_src_lexing_tools__WEBPACK_IMPORTED_MODULE_0__[\"isWhitespace\"](c), \"\")))(this);\n    this.resetCheckpoint();\n    let unexpected = \"<?>\";\n    if (r.success) unexpected = r.value;\n    return new ParseError(this.pos.clone(), expF, unexpected, ctxName, ctxPos, msg);\n  }\n\n  parseError(exp, msg) {\n    return this.parseErrorF(() => exp, msg);\n  }\n\n}\nfunction mkParseState(s, splices = []) {\n  // $FlowFixMe \n  return new ParseState(s[Symbol.iterator](), splices);\n}\nfunction ok(t, c = true) {\n  return {\n    success: true,\n    value: t,\n    consumed: c\n  };\n}\nfunction fail(es, c = false) {\n  return failF(() => es, c);\n}\nfunction failF(ef, c = false) {\n  return {\n    success: false,\n    expecting: ef,\n    consumed: c\n  };\n}\nclass ParseError extends Error {\n  constructor(pos, expF, unexp, ctxName, ctxPos, msg) {\n    super();\n    this._pos = pos;\n    this._expecting = expF;\n    this._unexpected = unexp;\n    this._ctxName = ctxName;\n    this._ctxPos = ctxPos;\n    this._msg = msg;\n  }\n\n  get name() {\n    return \"HotDrink Parse Error\";\n  }\n\n  set name(s) {\n    throw Error(\"Cannot set the name of ParseError\");\n  }\n\n  get message() {\n    let msg = this._pos.toString() + \"\\n\";\n    if (this._msg != null) msg += this._msg + \"\\n\";\n\n    let e = this._formatExpecting();\n\n    let u = this._unexpected != null ? this._unexpected : \"<eof>\";\n    if (e !== \"\") msg += \"Expecting \" + e + \". \";\n    msg += \"Unexpected \" + u + \"\\n\";\n\n    if (this._ctxName != null && this._ctxPos != null) {\n      msg += \"\\n\" + \"  while parsing \" + this._ctxName + \" (\" + this._ctxPos.toString() + \")\\n\";\n    }\n\n    return msg;\n  }\n\n  set message(s) {\n    throw Error(\"Cannot set the message of ParseError\");\n  }\n\n  _formatExpecting() {\n    let es = this._expecting();\n\n    if (es.length == 1) return es[0];\n    if (es.length > 1) return \"one of (\" + es.join(\", \") + \")\";\n    return \"\";\n  }\n\n}\nfunction item(ps) {\n  let v = ps.advance();\n  if (v == null) return fail([\"<item>\"]);else return ok(v);\n}\n;\nfunction peekItem(ps) {\n  let v = ps.peek();\n  if (v == null) return fail([\"<peek-item>\"]);else return ok(v, false);\n}\nfunction failure(ps) {\n  return fail([]);\n}\nfunction ret(v, consumed = false) {\n  return ps => ok(v, consumed);\n}\nfunction eof(ps) {\n  return peekItem(ps).success ? fail([\"<eof>\"]) : ok(null, false);\n}\nfunction sat(predicate, name = \"<sat: ?>\") {\n  let f = ps => {\n    let r = peekItem(ps);\n    if (r.success && predicate(r.value)) return item(ps);else return fail([name]);\n  };\n\n  f.parserName = name;\n  return f;\n}\nfunction pChar(c) {\n  return sat(x => x === c, c);\n}\nfunction pChars(cs) {\n  return sat(x => Object(_src_utilities__WEBPACK_IMPORTED_MODULE_2__[\"some\"])(v => v === x, cs), `<any of '${cs}'>`);\n}\nconst alphaPlus = sat(_src_lexing_tools__WEBPACK_IMPORTED_MODULE_0__[\"isAlphaPlus\"], \"<letter>\");\nconst alphaNum = sat(_src_lexing_tools__WEBPACK_IMPORTED_MODULE_0__[\"isAlphaNum\"], \"<letter or digit>\");\nconst digit = sat(_src_lexing_tools__WEBPACK_IMPORTED_MODULE_0__[\"isDigit\"], \"<digit>\");\n\nfunction many(p) {\n  return oneOf(many1(p), ret([]));\n}\nfunction many1(p) {\n  return ps => {\n    return lift((v, vs) => {\n      vs.unshift(v);\n      return vs;\n    }, p, many(p))(ps);\n  };\n}\nfunction exactString(s) {\n  let result = ps => {\n    ps.checkpoint();\n\n    for (let c of s) {\n      let r = item(ps);\n\n      if (r.success && r.value != c || !r.success) {\n        ps.resetCheckpoint();\n        return fail([s]);\n      }\n    }\n\n    ps.forgetCheckpoint();\n    return ok(s, s.length > 0); // consumes if nonzero length\n  };\n\n  result.parserName = s;\n  return result;\n}\nconst lineComment = lift((pre, rest, nl) => pre + rest.join('') + nl, exactString(\"//\"), many(sat(t => t !== '\\n')), // fails at '\\n' and also at <eof>\noneOf(pChar('\\n'), pBind_(eof, ret(\"\"))));\nconst blockComment = lift((pre, rest, post) => pre + rest.join('') + post, exactString(\"/*\"), many(pBind_(pNot(exactString(\"*/\")), item)), oneOf(exactString(\"*/\"), pBind_(eof, ret(\"\"))));\n\nconst onews = sat(_src_lexing_tools__WEBPACK_IMPORTED_MODULE_0__[\"isWhitespace\"], \"<whitespace>\");\nconst manyws = lift(a => a.join(''), many(oneOf(onews, lineComment, blockComment)));\n\nfunction pBind(p, f) {\n  return ps => {\n    const r1 = p(ps);\n    if (!r1.success) return r1; // p failed, hence fail\n\n    let r2 = f(r1.value)(ps);\n    if (!r2.consumed) r2.consumed = r1.consumed; // consumed is true if either consumed\n\n    return r2;\n  };\n}\nfunction pBind_(p, q) {\n  return pBind(p, _ => q);\n}\nfunction opt(p, v) {\n  return ps => {\n    ps.checkpoint();\n    let r = p(ps);\n\n    if (r.success) {\n      ps.forgetCheckpoint();\n      return ok(r.value, r.consumed);\n    } else {\n      ps.resetCheckpoint();\n      return ok(v, false);\n    }\n  };\n}\nconst _ignoreTag = {};\nfunction ignore(p) {\n  return lift(() => _ignoreTag, p);\n}\nfunction lift(f, ...parsers) {\n  return ps => {\n    let rs = [];\n    let consumed = false;\n\n    for (let p of parsers) {\n      let r = p(ps);\n      r.consumed = r.consumed || consumed;\n      consumed = r.consumed;\n      if (!r.success) return r;\n      if (r.value !== _ignoreTag) rs.push(r.value);\n    }\n\n    return ok(f(...rs));\n  };\n}\nfunction lift2(f) {\n  return (p1, p2) => lift(f, p1, p2);\n}\nfunction lift3(f) {\n  return (p1, p2, p3) => lift(f, p1, p2, p3);\n}\nfunction lift4(f) {\n  return (p1, p2, p3, p4) => lift(f, p1, p2, p3, p4);\n}\nfunction lift5(f) {\n  return (p1, p2, p3, p4, p5) => lift(f, p1, p2, p3, p4, p5);\n}\nfunction go(pg) {\n  return function (ps) {\n    let consumed = false;\n    let pr = pg.next();\n\n    while (!pr.done) {\n      let r = pr.value(ps);\n      r.consumed = r.consumed || consumed;\n      consumed = r.consumed;\n      if (!r.success) return r;\n      pr = pg.next(r.value);\n    }\n\n    if (pr.value === undefined) {\n      // if this happens, the generator is faulty\n      _src_hdconsole__WEBPACK_IMPORTED_MODULE_3__[\"hdconsole\"].assert(false, \"Incorrect yield parser\");\n      return fail([\"<?>\"], consumed);\n    } else return ok(pr.value, consumed);\n  };\n}\nfunction inBetween(p, open, close) {\n  return go(function* () {\n    yield open;\n    const v = yield p;\n    yield close;\n    return v;\n  }());\n}\nfunction parens(p) {\n  return inBetween(p, word(\"(\"), word(\")\"));\n}\nfunction oneOf(...qs) {\n  return ps => {\n    let es = [];\n\n    for (let q of qs) {\n      let r = q(ps);\n      if (r.success || r.consumed) return r;else es.push(r.expecting);\n    } // all failed without consuming, concatenate expecting info\n\n\n    return failF(() => Array.prototype.concat(...es.map(f => f()))); // one level flatten (Array.flat() not yet in many browsers)\n    // FIXME: remove duplicates\n  };\n}\nfunction pNot(p) {\n  return ps => {\n    ps.checkpoint();\n    let r = p(ps);\n\n    if (!r.success && !r.consumed) {\n      ps.resetCheckpoint();\n      return ok(null, false);\n    }\n\n    let consumed = r.consumed;\n\n    if (r.success) {\n      ps.resetCheckpoint();\n      consumed = false;\n    } else {\n      ps.forgetCheckpoint();\n    }\n\n    return fail([\"not(\" + p.parserName + \")\"], consumed);\n  };\n}\nfunction until(p) {\n  return lift(ls => ls.join(''), many(pBind_(pNot(p), item)));\n}\nfunction notFollowedBy(q1, q2) {\n  return ps => {\n    ps.checkpoint();\n    let r1 = q1(ps);\n\n    if (!r1.success) {\n      ps.forgetCheckpoint();\n      return r1;\n    }\n\n    let r2 = pNot(q2)(ps);\n\n    if (r2.success) {\n      ps.forgetCheckpoint();\n      return r1;\n    }\n\n    if (r2.consumed) {\n      ps.forgetCheckpoint();\n      return r2;\n    } else {\n      ps.resetCheckpoint();\n      return fail([q1.parserName + \" not followed by \" + q2.parserName]);\n    }\n  };\n}\nfunction pTry(q) {\n  return ps => {\n    ps.checkpoint();\n    let r = q(ps);\n\n    if (r.success) {\n      ps.forgetCheckpoint();\n      return r;\n    }\n\n    ps.resetCheckpoint();\n    return fail([q.parserName]);\n  };\n}\nfunction must(p, msg) {\n  return ps => {\n    let r = p(ps);\n    if (r.success) return r;else throw ps.parseErrorF(r.expecting, msg);\n  };\n}\nfunction named(p, name = \"<?>\") {\n  let q = ps => {\n    let r = p(ps);\n    if (!r.success) r.expecting = () => [name];\n    return r;\n  };\n\n  q.parserName = name;\n  return q;\n}\nfunction token(q) {\n  return lift((v, _) => v, q, manyws);\n}\nfunction word(s) {\n  return token(exactString(s));\n}\n\nfunction keyword(s) {\n  return named(token(notFollowedBy(exactString(s), named(alphaNum, \"<alphanum>\"))), `<keyword: ${s}>`);\n}\n\nfunction identifier(ps) {\n  return lift((h, t, _) => h + t.join(''), sat(_src_lexing_tools__WEBPACK_IMPORTED_MODULE_0__[\"isAlphaPlus\"], \"<identifier>\"), many(sat(_src_lexing_tools__WEBPACK_IMPORTED_MODULE_0__[\"isAlphaNum\"])), manyws)(ps);\n}\nlet nat = lift(ds => Number(ds.join('')), named(token(notFollowedBy(named(many1(digit), \"<nat>\"), named(alphaPlus, \"<alphaplus>\"))), \"<nat>\"));\n\nfunction sepList(element, sep) {\n  return ps => {\n    let r = element(ps);\n    if (!r.success) return r.consumed ? r : ok([], false); // if element parser consumed and failed, then fail\n\n    let rs = many(pBind_(sep, element))(ps);\n    rs.consumed = r.consumed || rs.consumed;\n    if (rs.success) rs.value.unshift(r.value);\n    return rs;\n  };\n}\n\nconst currentPos = ps => ok(ps.pos.clone(), false);\n\n\nfunction context(str, p) {\n  return ps => {\n    ps.pushContext(str);\n\n    try {\n      return p(ps);\n    } finally {\n      ps.popContext();\n    }\n\n    ;\n  };\n}\nfunction hdl(strs, ...splices) {\n  let pstr = \"\";\n\n  for (let i = 0; i < splices.length; ++i) {\n    pstr += strs[i];\n    pstr += '###' + i + '###';\n  }\n\n  if (strs.length > 0) pstr += strs[strs.length - 1];\n  let ps = mkParseState(pstr, splices);\n  return ps;\n}\n\nconst pSplice = ps => pBind(inBetween(nat, exactString(\"###\"), word(\"###\")), key => ret(ps.getSplice(key)))(ps);\n\n\n\n//# sourceURL=webpack://hd/./src/parsing.js?");

/***/ }),

/***/ "./src/peek-iterator.js":
/*!******************************!*\
  !*** ./src/peek-iterator.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PeekIterator; });\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ \"./src/utilities.js\");\n// [[file:~/git/hd4/org/peek-iterator.org::*Tangle][Tangle:1]]\n // [[file:~/git/hd4/org/peek-iterator.org::*Peek%20Iterator][]]\n\nclass PeekIterator {\n  constructor(iter) {\n    this._iter = iter;\n    this._currentIndex = 0;\n    this._firstIndex = 0;\n    this._buffer = [];\n    this._checkpoints = [];\n  }\n\n  next() {\n    if (this._fetch(1) === 0) return {\n      done: true\n    };\n    let r = {\n      value: this._at(this._currentIndex++),\n      done: false\n    };\n\n    this._collect();\n\n    return r;\n  }\n\n  _ind2buf(i) {\n    return i - this._firstIndex;\n  }\n\n  _at(i) {\n    return this._buffer[this._ind2buf(i)];\n  }\n\n  _fetch(n) {\n    let currentlyRead = this._buffer.length - this._ind2buf(this._currentIndex);\n\n    let toRead = n - currentlyRead;\n\n    while (toRead > 0) {\n      let v = this._iter.next();\n\n      if (v.done) break;\n      toRead--;\n\n      this._buffer.push(v.value);\n    }\n\n    return n - toRead;\n  }\n\n  _collect() {\n    let toRemove = this._checkpoints.length === 0 ? this._currentIndex - this._firstIndex : this._checkpoints[0].index - this._firstIndex;\n    this._firstIndex += toRemove;\n\n    this._buffer.splice(0, toRemove);\n  }\n\n  checkpoint(d) {\n    this._checkpoints.push({\n      index: this._currentIndex,\n      value: d\n    });\n  }\n\n  forgetCheckpoint() {\n    if (this._checkpoints.pop() === undefined) {\n      throw \"Trying to forget a nonexisting checkpoint in PeekIterator\";\n    }\n\n    this._collect();\n  }\n\n  reset() {\n    if (this._checkpoints.length === 0) {\n      throw \"Trying to reset to a nonexisting checkpoint in PeekIterator\";\n    }\n\n    let r = this._checkpoints.pop();\n\n    this._currentIndex = r.index;\n\n    this._collect();\n\n    return r.value;\n  }\n\n  peek() {\n    this._fetch(1);\n\n    return this._at(this._currentIndex);\n  }\n\n  peekMany(n) {\n    this._fetch(n);\n\n    return this._buffer.slice(this._ind2buf(this._currentIndex), this._ind2buf(this._currentIndex + n));\n  }\n\n} // ends here\n// Tangle:1 ends here\n\n//# sourceURL=webpack://hd/./src/peek-iterator.js?");

/***/ }),

/***/ "./src/utilities.js":
/*!**************************!*\
  !*** ./src/utilities.js ***!
  \**************************/
/*! exports provided: equals, orderedSetEquals, orderedMapEquals, setEquals, mapEquals, copy, subsetOf, modifyMapValue, setUnion, setUnionTo, setUnionToWithDiff, setDifference, setDifferenceTo, mkEmptyIterable, mkSingletonIterable, mkEmptyIterator, iteratorToIterable, iterableToIterator, map, filter, until, every, some, forEach, adjacentFind, isSortedBy, count, first, firstKeepOpen, rest, foldl, join, zipWith, zip, bisimilar, bisame, every2, sameElements, OneToManyMap, mkRefCounted, setUniqueHandler, retain, release, refCount, isUnique, RefList, RefListNode, ListNode, LinkedList, PriorityList, ObservableReference, throw_on_null, nonnull_cast, BinaryHeap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"orderedSetEquals\", function() { return orderedSetEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"orderedMapEquals\", function() { return orderedMapEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setEquals\", function() { return setEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapEquals\", function() { return mapEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subsetOf\", function() { return subsetOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"modifyMapValue\", function() { return modifyMapValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setUnion\", function() { return setUnion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setUnionTo\", function() { return setUnionTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setUnionToWithDiff\", function() { return setUnionToWithDiff; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setDifference\", function() { return setDifference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setDifferenceTo\", function() { return setDifferenceTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkEmptyIterable\", function() { return mkEmptyIterable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkSingletonIterable\", function() { return mkSingletonIterable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkEmptyIterator\", function() { return mkEmptyIterator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"iteratorToIterable\", function() { return iteratorToIterable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"iterableToIterator\", function() { return iterableToIterator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"map\", function() { return map; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filter\", function() { return filter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"until\", function() { return until; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"every\", function() { return every; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"some\", function() { return some; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjacentFind\", function() { return adjacentFind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isSortedBy\", function() { return isSortedBy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"count\", function() { return count; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"first\", function() { return first; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"firstKeepOpen\", function() { return firstKeepOpen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rest\", function() { return rest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"foldl\", function() { return foldl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"join\", function() { return join; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zipWith\", function() { return zipWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zip\", function() { return zip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bisimilar\", function() { return bisimilar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bisame\", function() { return bisame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"every2\", function() { return every2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sameElements\", function() { return sameElements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneToManyMap\", function() { return OneToManyMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkRefCounted\", function() { return mkRefCounted; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setUniqueHandler\", function() { return setUniqueHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"retain\", function() { return retain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"release\", function() { return release; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"refCount\", function() { return refCount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isUnique\", function() { return isUnique; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RefList\", function() { return RefList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RefListNode\", function() { return RefListNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ListNode\", function() { return ListNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkedList\", function() { return LinkedList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PriorityList\", function() { return PriorityList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObservableReference\", function() { return ObservableReference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"throw_on_null\", function() { return throw_on_null; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nonnull_cast\", function() { return nonnull_cast; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BinaryHeap\", function() { return BinaryHeap; });\n/* harmony import */ var _hdconsole_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hdconsole.js */ \"./src/hdconsole.js\");\n/* harmony import */ var _observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observable.js */ \"./src/observable.js\");\n// [[file:~/git/hd4/org/utilities.org::*Tangle][Tangle:1]]\n\n // [[file:~/git/hd4/org/utilities.org::*Equality][]]\n\nfunction equals(a, b) {\n  a = a;\n  b = b;\n  if (a === b) return true;\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n\n    for (let i = 0; i < a.length; ++i) if (!equals(a[i], b[i])) return false;\n\n    return true;\n  }\n\n  if (a instanceof Set && b instanceof Set) return orderedSetEquals(a, b); // Equality of keys is by ===, not by equals\n\n  if (a instanceof Map && b instanceof Map) return orderedMapEquals(a, b);\n\n  if (typeof a === 'object' && a !== null) {\n    // for any other kind of object (even function object)\n    // find .equals method if one exists\n    if (typeof a.equals === 'function') return a.equals(b);else if (b != null) {\n      // otherwise recurse through all members\n      let ak = Object.keys(a),\n          bk = Object.keys(b);\n      if (ak.length !== bk.length) return false;\n\n      for (let m of ak) if (!equals(a[m], b[m])) return false;\n\n      return true;\n    }\n  }\n\n  if (typeof a === 'function' && typeof a.equals === 'function') return a.equals(b); // by default functions are the same only if === says so; but if a function object has\n  // the equals member, then that member determines equality\n\n  return false;\n} // two ordered Sets are equal if they have the same keys in the same order\n\nfunction orderedSetEquals(s1, s2) {\n  if (s1.size !== s2.size) return false;\n  return bisame(s1, s2);\n} // two ordered Maps are equal if they have the same keys, in the same\n// order, and for each key, values are equal\n\nfunction orderedMapEquals(s1, s2) {\n  if (s1.size !== s2.size) return false;\n  return every2(([key1, value1], [key2, value2]) => key1 === key2 && equals(value1, value2), s1, s2);\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Set%20and%20Map%20equals%20---%20unordered][]]\n// two Sets are `set equal' if they have the same keys\n\nfunction setEquals(s1, s2) {\n  if (s1.size !== s2.size) return false;\n\n  for (let k of s1.keys()) if (!s2.has(k)) return false;\n\n  return true;\n} // two Maps are `set equal' if they have the same keys and for each key, values are equal\n\nfunction mapEquals(s1, s2) {\n  if (s1.size !== s2.size) return false;\n\n  for (let [k, v] of s1) {\n    if (!equals(s2.get(k), v)) return false;\n  }\n\n  return true;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Copy][]]\n\nfunction copy(a) {\n  return _copy(a);\n}\n\nfunction _copy(a) {\n  if (Array.isArray(a)) return a.map(v => copy(v));\n  if (a instanceof Set) return new Set(a);\n  if (a instanceof Map) return new Map(map(([k, v]) => [k, copy(v)], a));\n\n  if (typeof a === 'object' && a !== null) {\n    if (typeof a.copy === 'function') return a.copy();else {\n      let b = Object.create(Object.getPrototypeOf(a));\n\n      for (let m of Object.keys(a)) b[m] = copy(a[m]);\n\n      return b;\n    }\n  }\n\n  if (typeof a === 'function' && typeof a.copy === 'function') return a.copy(); // here should be a value, or something that is shared by reference\n\n  return a;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Subset][]]\n\n\nfunction subsetOf(sub, sup) {\n  for (let k of sub.keys()) if (!sup.has(k)) return false;\n\n  return true;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Apply%20a%20function%20over%20a%20value%20of%20a%20specific%20key][]]\n\nfunction modifyMapValue(m, k, fn) {\n  let newv = fn(m.get(k));\n  m.set(k, newv);\n  return newv;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Set%20union][]]\n\nfunction setUnion(s1, s2) {\n  let s = new Set();\n  setUnionTo(s, s1);\n  setUnionTo(s, s2);\n  return s;\n}\nfunction setUnionTo(s1, s2) {\n  for (let v of s2) s1.add(v);\n}\nfunction setUnionToWithDiff(s1, s2) {\n  let diff = new Set();\n\n  for (let v of s2) if (!s1.has(v)) {\n    s1.add(v);\n    diff.add(v);\n  }\n\n  return diff;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Set%20difference][]]\n\nfunction setDifference(s1, s2) {\n  let s = new Set();\n\n  for (let v of s1) if (!s2.has(v)) s.add(v);\n\n  return s;\n}\nfunction setDifferenceTo(s1, s2) {\n  for (let v of s2) s1.delete(v);\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Constructing%20iterables][]]\n\nfunction* mkEmptyIterable() {}\nfunction* mkSingletonIterable(v) {\n  yield v;\n}\nfunction mkEmptyIterator() {\n  // flowtype wants iterators to have @@iterator, which is an iterable's method,\n  // and does not need to be in iterator. To appease flowtype,\n  // we define a dummy in flowtype-comments\n  return {\n    /*:: @@iterator(): Iterator<T> { return ({}: any); }, */\n    // $FlowFixMe: computed property\n    next: () => ({\n      done: true,\n      value: undefined\n    })\n  };\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Constructing%20iterables][]]\n\nfunction iteratorToIterable(it) {\n  let v = {};\n\n  v[Symbol.iterator] = function () {\n    return it;\n  };\n\n  return v; //    return ({ [Symbol.iterator]: () => it }: any);\n}\nfunction iterableToIterator(it) {\n  return it[Symbol.iterator]();\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*map%20and%20filter][]]\n\nfunction map(fn, iterable) {\n  return {\n    [Symbol.iterator]: () => {\n      const iterator = iterable[Symbol.iterator]();\n      let mapIterator = {};\n\n      mapIterator.next = () => {\n        const {\n          done,\n          value\n        } = iterator.next();\n        return {\n          done,\n          value: done ? undefined : fn(value)\n        };\n      };\n\n      if (typeof iterator.return === 'function') {\n        mapIterator.return = v => {\n          return iterator.return(v);\n        };\n      }\n\n      ;\n\n      if (typeof iterator.throw === 'function') {\n        mapIterator.throw = e => {\n          return iterator.throw(e);\n        }; // assuming that if .throw throws, iterator relases resources, sets itself closed etc.\n\n      }\n\n      ;\n      return mapIterator;\n    }\n  };\n}\nfunction filter(fn, iterable) {\n  return {\n    [Symbol.iterator]: () => {\n      const iterator = iterable[Symbol.iterator]();\n      let filterIterator = {};\n\n      filterIterator.next = () => {\n        let done = false;\n        let value = undefined;\n\n        do {\n          ({\n            done,\n            value\n          } = iterator.next());\n        } while (!done && !fn(value));\n\n        return {\n          done,\n          value\n        };\n      };\n\n      if (typeof iterator.return === 'function') {\n        filterIterator.return = v => {\n          return iterator.return(v);\n        };\n      }\n\n      ;\n\n      if (typeof iterator.throw === 'function') {\n        filterIterator.throw = e => {\n          return iterator.throw(e);\n        }; // assuming that if .throw throws, iterator relases resources, sets itself closed etc.\n\n      }\n\n      ;\n      return filterIterator;\n    }\n  };\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Until][]]\n\nfunction until(fn, iterable) {\n  return {\n    [Symbol.iterator]: () => {\n      const iterator = iterable[Symbol.iterator]();\n      let untilIterator = {};\n\n      let step = () => iterator.next();\n\n      untilIterator.done = false;\n\n      untilIterator.next = () => {\n        if (untilIterator.done) return {\n          done: true\n        };\n        let {\n          done,\n          value\n        } = step();\n\n        step = () => iterator.next();\n\n        if (done) {\n          // normal closing of iterator: assuming it releases resources \n          untilIterator.done = true;\n          return {\n            done: true\n          };\n        }\n\n        done = fn(value);\n\n        if (done) {\n          if (typeof iterator.return === 'function') iterator.return(); // call return to release resources\n\n          return {\n            done: true\n          };\n        } else {\n          return {\n            done: false,\n            value: value\n          };\n        }\n      };\n\n      if (typeof iterator.return === 'function') {\n        untilIterator.return = v => {\n          return iterator.return(v);\n        };\n      }\n\n      ;\n\n      if (typeof iterator.throw === 'function') {\n        untilIterator.throw = e => {\n          step = () => iterator.throw(e);\n\n          return untilIterator.next(); // we do not catch exceptions and call iterator.return; assuming that\n          // if iterator.throw throws, iterator releases resources \n        };\n      }\n\n      ;\n      return untilIterator;\n    }\n  };\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Every%20and%20some][]]\n\nfunction every(fn, iterable) {\n  for (let i of iterable) if (!fn(i)) return false;\n\n  return true;\n}\nfunction some(fn, iterable) {\n  for (let i of iterable) if (fn(i)) return true;\n\n  return false;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*forEach][]]\n\nfunction forEach(fn, iterable) {\n  for (let i of iterable) fn(i);\n\n  return fn;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Adjacent%20find][]]\n\nfunction adjacentFind(cmp, iterable) {\n  let iter = iterableToIterator(iterable);\n  let r = iter.next();\n  if (r.done) return null;\n  let prevVal = r.value;\n\n  while (true) {\n    let curr = iter.next();\n    if (curr.done) return null;\n\n    if (cmp(prevVal, curr.value)) {\n      if (typeof iter.return === 'function') iter.return(); // release resources\n      // FIXME: how to convince flowtype that return may exist?\n\n      return [prevVal, curr.value];\n    } else {\n      prevVal = curr.value;\n    }\n  }\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Adjacent%20find][]]\n\nfunction isSortedBy(cmp, iterable) {\n  return adjacentFind((a, b) => !cmp(a, b), iterable) === null;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Count%20elements][]]\n\nfunction count(iterable) {\n  let i = 0;\n\n  for (let _ of iterable) ++i;\n\n  return i;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*First%20and%20rest][]]\n\nfunction first(iterable) {\n  const iterator = iterable[Symbol.iterator]();\n  let r = iterator.next();\n  if (r.done) return undefined;else {\n    if (typeof iterator.return === 'function') iterator.return();\n    return r.value;\n  }\n}\nfunction firstKeepOpen(iterable) {\n  let r = iterable[Symbol.iterator]().next();\n  if (r.done) return undefined;else return r.value;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*First%20and%20rest][]]\n\nfunction rest(iterable) {\n  let iterator = iterableToIterator(iterable);\n  iterator.next();\n  return iteratorToIterable(iterator);\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Foldl][]]\n\nfunction foldl(fn, u, iterable) {\n  let acc = u;\n\n  for (let t of iterable) acc = fn(t, acc);\n\n  return acc;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Join:%20flatten%20an%20iterable%20of%20iterables][]]\n\nfunction join(it1) {\n  return {\n    [Symbol.iterator]: () => {\n      let outerIt = iterableToIterator(it1);\n      let innerIt;\n      let innerDone = true;\n      let allDone = false; // FIXME can one call next repeatedly after past the end?\n\n      return {\n        next: () => {\n          if (allDone) return {\n            done: true\n          }; //            let a: { value: Iterable<T>, done: false } | { done: true };\n          //            let b: { value: T, done: false } | { done: true };\n\n          let a;\n          let b;\n\n          while (true) {\n            if (innerDone == true) {\n              a = outerIt.next();\n              if (a.done) return {\n                done: true\n              };\n              innerIt = iterableToIterator(a.value);\n            }\n\n            b = innerIt.next();\n\n            if (b.done) {\n              innerDone = true;\n              continue;\n            }\n\n            innerDone = false;\n            return {\n              done: false,\n              value: b.value\n            };\n          }\n        },\n        return: v => {\n          if (allDone) return {\n            done: true,\n            value: v\n          };\n          allDone = true;\n\n          if (!innerDone && typeof innerIt.return === 'function') {\n            // FIXME: how to express optional iterator properties in flowtype?\n            innerIt.return(v); // close the currently open inner iterator\n          }\n\n          return {\n            done: true,\n            value: v\n          };\n        },\n        throw: e => {\n          if (allDone) throw e; // FIXME: think how to deal with throw\n        }\n      };\n    }\n  };\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Zip%20and%20zipWith][]]\n\nfunction zipWith(fn, it1, it2) {\n  let done = false;\n  return {\n    [Symbol.iterator]: () => {\n      const i1 = it1[Symbol.iterator](),\n            i2 = it2[Symbol.iterator]();\n      return {\n        next: () => {\n          if (done) return {\n            done: true\n          };\n          const a = i1.next(),\n                b = i2.next();\n          done = a.done || b.done;\n          if (!a.done && typeof i1.return === 'function') i1.return();\n          if (!b.done && typeof i2.return === 'function') i2.return();\n          if (done) return {\n            done: true\n          };else {\n            return {\n              done: false,\n              value: fn(a.value, b.value)\n            };\n          }\n        },\n        return: v => {\n          if (typeof i1.return === 'function') i1.return();\n          if (typeof i2.return === 'function') i2.return();\n          done = true;\n          return {\n            done: true,\n            value: v\n          };\n        }\n      };\n    }\n  };\n}\nfunction zip(it1, it2) {\n  return zipWith((a, b) => [a, b], it1, it2);\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Bisimilarity][]]\n\nfunction bisimilar(it1, it2) {\n  return every2((a, b) => equals(a, b), it1, it2);\n}\nfunction bisame(it1, it2) {\n  return every2((a, b) => a === b, it1, it2);\n}\nfunction every2(fn, it1, it2) {\n  const i1 = it1[Symbol.iterator](),\n        i2 = it2[Symbol.iterator]();\n\n  while (true) {\n    const a = i1.next(),\n          b = i2.next();\n\n    if (!a.done && !b.done) {\n      if (!fn(a.value, b.value)) return false;else continue;\n    }\n\n    if (a.done && b.done) return true; // in this case i1 and i2 should have released resources\n\n    if (!a.done) {\n      if (typeof i1.return === 'function') i1.return();\n      return false;\n    }\n\n    if (!b.done) {\n      if (typeof i2.return === 'function') i2.return();\n      return false;\n    }\n  }\n\n  return true; // dead code; added to appease flowtype\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*SameElements][]]\n\nfunction sameElements(a, b) {\n  let m = new Map();\n\n  for (let k of a) modifyMapValue(m, k, c => c === undefined ? 1 : c + 1);\n\n  for (let k of b) {\n    let c = m.get(k);\n    if (c === 1) m.delete(k);else if (c === undefined) return false; // this closes b\n    else m.set(k, c - 1);\n  }\n\n  return m.size === 0;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*OneToManyMap][]]\n\nclass OneToManyMap {\n  constructor() {\n    this._m = new Map();\n  }\n\n  hasKey(k) {\n    return this._m.has(k);\n  }\n\n  keys() {\n    return this._m.keys();\n  }\n\n  values(k) {\n    let s = this._m.get(k);\n\n    if (s !== undefined) return s.values();else return mkEmptyIterable();\n  }\n\n  countKeys() {\n    return this._m.size;\n  }\n\n  count(k) {\n    let s = this._m.get(k);\n\n    return s === undefined ? 0 : s.size;\n  }\n\n  addKey(k) {\n    if (this._m.get(k) === undefined) this._m.set(k, new Set());\n    return this;\n  }\n\n  add(k, v) {\n    let s = this._m.get(k);\n\n    if (s === undefined) {\n      s = new Set();\n\n      this._m.set(k, s);\n    }\n\n    s.add(v);\n    return this;\n  }\n\n  addMany(k, ite) {\n    let s = this._m.get(k);\n\n    if (s === undefined) {\n      s = new Set();\n\n      this._m.set(k, s);\n    } // even with empty iterator, key is always added\n\n\n    for (let v of ite) s.add(v);\n  }\n\n  remove(k, v) {\n    let s = this._m.get(k);\n\n    if (s === undefined) return false;else return s.delete(v);\n  }\n\n  removeKey(k) {\n    this._m.delete(k);\n  }\n\n  clear() {\n    this._m.clear();\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Reference%20Counting][]]\n\nlet refCountMap = new WeakMap();\nlet disposerMap = new WeakMap();\nlet uniqueHandlerMap = new WeakMap(); // shall only be called after initRefCounting called\n\nfunction mkRefCounted(o, disposer, uniqueHandler) {\n  _hdconsole_js__WEBPACK_IMPORTED_MODULE_0__[\"hdconsole\"].assert(refCount(o) == 0, \"trying to make an object reference counted twice\");\n  disposerMap.set(o, disposer);\n  if (uniqueHandler != null) uniqueHandlerMap.set(o, uniqueHandler);\n  refCountMap.set(o, 1);\n  return o;\n}\nfunction setUniqueHandler(o, uniqueHandler) {\n  uniqueHandlerMap.set(o, uniqueHandler);\n}\n;\nfunction retain(o) {\n  let cnt = refCountMap.get(o);\n  _hdconsole_js__WEBPACK_IMPORTED_MODULE_0__[\"hdconsole\"].assert(cnt != null, \"trying to retain a non-refcounted object\");\n  refCountMap.set(o, cnt + 1);\n  return o;\n}\nfunction release(o) {\n  let cnt = refCountMap.get(o);\n  _hdconsole_js__WEBPACK_IMPORTED_MODULE_0__[\"hdconsole\"].assert(cnt != null && cnt > 0, \"trying to release an already released object\");\n  --cnt;\n  refCountMap.set(o, cnt);\n  if (cnt > 1) return cnt;\n\n  if (cnt === 1) {\n    let uniqueHandler = uniqueHandlerMap.get(o);\n    if (uniqueHandler != null) uniqueHandler(o);\n  } else {\n    // cnt === 0\n    let disposer = disposerMap.get(o);\n    if (disposer != null) disposer(o);\n  }\n\n  return cnt;\n}\nfunction refCount(o) {\n  let cnt = refCountMap.get(o);\n  return cnt === undefined ? 0 : cnt;\n}\nfunction isUnique(o) {\n  return refCount(o) === 1;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*List%20of%20reference%20counted%20objects][]]\n\nclass RefList {\n  constructor() {\n    this._head = null;\n  }\n\n  front() {\n    if (this._head != null) return this._head.data;\n  }\n\n  pushFront(t) {\n    this._head = new RefListNode(this._head, t);\n    return this._head;\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*List%20of%20reference%20counted%20objects][]]\n\nclass RefListNode {\n  constructor(n, d) {\n    console.assert(refCount(d) > 0);\n    this.next = n;\n    this.data = d;\n  }\n\n  releaseTail() {\n    let n = this.next;\n\n    while (n != null) {\n      release(n.data);\n      n = n.next;\n    }\n\n    this.next = null;\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Linked%20List][]]\n\nclass ListNode {\n  constructor(p, n, d) {\n    this.prev = p;\n    this.next = n;\n    this.data = d;\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Linked%20List][]]\n\nclass LinkedList {\n  constructor() {\n    this._head = null;\n    this._tail = null;\n    this._size = 0;\n  }\n\n  insertNode(pos, n) {\n    if (pos == null) {\n      n.prev = this._tail;\n      n.next = null;\n      this._tail = n;\n    } else {\n      n.prev = pos.prev;\n      n.next = pos;\n      pos.prev = n;\n    }\n\n    if (n.prev == null) this._head = n;else n.prev.next = n;\n    this._size++;\n    return n;\n  }\n\n  insert(pos, v) {\n    return this.insertNode(pos, new ListNode(null, null, v));\n  }\n\n  pushFront(v) {\n    return this.insert(this._head, v);\n  }\n\n  pushNodeFront(n) {\n    return this.insertNode(this._head, n);\n  }\n\n  pushBack(v) {\n    return this.insert(null, v);\n  }\n\n  pushNodeBack(n) {\n    return this.insertNode(null, n);\n  }\n\n  removeNode(pos) {\n    if (pos.next == null) this._tail = pos.prev;else pos.next.prev = pos.prev;\n    if (pos.prev == null) this._head = pos.next;else pos.prev.next = pos.next;\n    this._size--;\n    return pos;\n  }\n\n  remove(pos) {\n    return this.removeNode(pos).data;\n  }\n\n  popFront() {\n    return this._head == null ? null : this.remove(this._head);\n  }\n\n  popBack() {\n    return this._tail == null ? null : this.remove(this._tail);\n  }\n  /*:: @@iterator(): Iterator<T> { return ({}: any); } */\n  // $FlowFixMe: computed property\n\n\n  [Symbol.iterator]() {\n    let curr = this._head;\n    return {\n      next: () => {\n        if (curr == null) return {\n          done: true\n        };else {\n          let r = {\n            value: curr.data,\n            done: false\n          };\n          curr = curr.next;\n          return r;\n        }\n      }\n    };\n  }\n\n  reverseIterator() {\n    let curr = this._tail;\n    return {\n      next: () => {\n        if (curr == null) return {\n          done: true\n        };else {\n          let r = {\n            value: curr.data,\n            done: false\n          };\n          curr = curr.prev;\n          return r;\n        }\n      }\n    };\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Linked%20List%20with%20random%20access][]]\n\nclass PriorityList {\n  size() {\n    return this._list._size;\n  }\n\n  constructor() {\n    this._nodeMap = new Map();\n    this._list = new LinkedList();\n    this._highestPriority = -1;\n    this._lowestPriority = 0;\n  } // FIXME: if insert in the middle, may have to assign priorities down (or up) to list\n  // For now this is not implemented, as it is unsure whether it will be needed or not\n  // insertBefore(t: ?T, u: T) {\n  //  let n = t != null ? this._nodeMap.get(t) : null;\n  //  this._list.insert(n, u); // inserts as last if t null or not found\n  // }\n  // Precondition: t is in the priority list\n\n\n  _access(t) {\n    let n = this._nodeMap.get(t);\n\n    if (n == null) console.log(t.name);\n    if (n == null) console.log(this.size());\n    _hdconsole_js__WEBPACK_IMPORTED_MODULE_0__[\"hdconsole\"].assert(n != null, \"element not found in priority list\");\n    if (n == null) throw \"Should not happen, element not found in priority list\"; // this is to appease flow\n\n    return n;\n  }\n\n  remove(t) {\n    let n = this._nodeMap.get(t);\n\n    if (n != null) {\n      // only remove if not already removed\n      this._nodeMap.delete(t);\n\n      this._list.remove(n);\n    }\n  }\n\n  promote(t) {\n    let node = this._access(t);\n\n    node.data.priority = ++this._highestPriority;\n\n    this._list.pushNodeFront(this._list.removeNode(node));\n  }\n\n  demote(t) {\n    let node = this._access(t);\n\n    node.data.priority = --this._lowestPriority;\n\n    this._list.pushNodeBack(this._list.removeNode(node));\n  }\n\n  get highestPriority() {\n    return this._highestPriority;\n  }\n\n  get lowestPriority() {\n    return this._lowestPriority;\n  }\n\n  priority(t) {\n    return this._access(t).data.priority;\n  }\n\n  pushBack(t) {\n    this._nodeMap.set(t, this._list.pushBack({\n      data: t,\n      priority: --this._lowestPriority\n    }));\n  }\n\n  pushFront(t) {\n    this._nodeMap.set(t, this._list.pushFront({\n      data: t,\n      priority: ++this._highestPriority\n    }));\n  } // an iterable that iterates over just the T values, ignores priority value\n\n\n  entries() {\n    return map(pd => pd.data, this);\n  }\n  /*:: @@iterator(): Iterator<PriData<T>> { return ({}: any); } */\n  // $FlowFixMe: computed property\n\n\n  [Symbol.iterator]() {\n    return this._list[Symbol.iterator]();\n  }\n\n  hasHigherPriority(a, b) {\n    return this._access(a).data.priority > this._access(b).data.priority;\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::#sec:observable-reference][]]\n\nclass ObservableReference {\n  // holds observers \n  // link to another reference\n  constructor(value = null) {\n    this._value = value;\n    this._subject = new _observable_js__WEBPACK_IMPORTED_MODULE_1__[\"Subject\"](o => {\n      o.next(this._value);\n    });\n    this._subscription = null;\n  }\n\n  subscribe(s) {\n    return this._subject.subscribe(s);\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(v) {\n    if (this._subscription != null) {\n      this._subscription.unsubscribe();\n\n      this._subscription = null;\n    }\n\n    this._setValue(v);\n  }\n\n  _setValue(v) {\n    if (this._value !== null) this._subject.sendNext(null);\n    this._value = v;\n    if (v !== null) this._subject.sendNext(v);\n  }\n\n  link(target) {\n    this.value = null; // unsubscribes, if already linked\n\n    this._subscription = target.subscribe(v => {\n      this._setValue(v);\n    });\n  }\n\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Flowtype][]]\n\nfunction throw_on_null(t) {\n  if (t == null) throw \"Expected non-null\";\n  return t;\n}\nfunction nonnull_cast(t) {\n  return t;\n} // ends here\n// [[file:~/git/hd4/org/utilities.org::*Heap%20Data%20Structure][]]\n\nclass BinaryHeap {\n  constructor(cmp) {\n    this._cmp = cmp;\n    this._data = [null]; // empty unused element at 0 allows simpler index math\n  }\n\n  size() {\n    return this._data.length - 1;\n  }\n\n  empty() {\n    return this.size() === 0;\n  }\n\n  _swap(i, j) {\n    let tmp = this._data[i];\n    this._data[i] = this._data[j];\n    this._data[j] = tmp;\n  }\n\n  _percolateUp(i) {\n    while (i >= 2) {\n      let parent = Math.floor(i / 2);\n\n      if (this._cmp(this._data[i], this._data[parent])) {\n        this._swap(i, parent);\n\n        i = parent;\n      } else break;\n    }\n  }\n\n  push(t) {\n    this._data.push(t);\n\n    this._percolateUp(this.size());\n  }\n\n  _percolateDown(i) {\n    while (2 * i <= this.size()) {\n      let smallerChild = this._minOfSiblings(2 * i);\n\n      if (!this._cmp(this._data[i], this._data[smallerChild])) {\n        this._swap(i, smallerChild);\n\n        i = smallerChild;\n      } else break;\n    }\n  }\n\n  _minOfSiblings(i) {\n    if (i >= this.size() || this._cmp(this._data[i], this._data[i + 1])) return i;else return i + 1;\n  }\n\n  pop() {\n    let ret = this._data[1];\n\n    let last = this._data.pop();\n\n    if (this.size() > 0) {\n      this._data[1] = last;\n\n      this._percolateDown(1);\n    }\n\n    return ret;\n  }\n\n} // ends here\n// Tangle:1 ends here\n\n//# sourceURL=webpack://hd/./src/utilities.js?");

/***/ })

/******/ });